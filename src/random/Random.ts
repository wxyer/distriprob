"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


export class Random {
  public static className: string;

  public static init0(): void {
    Random.className = "Random";
  }

  public static isState(x: any): x is IRandomState {
    return WELL512A.isState(x) || WELL1024A.isState(x) || ARC4.isState(x);
  }

  private gen: RandomNumGen;
  private width: number;

  constructor(
    seed: number | string | null | undefined | IRandomState,
    type: "WELL512A" | "WELL1024A" | "ARC4" | null | undefined
  ) {
    if (Random.isState(seed)) {
      if (typeof type !== "undefined" && type !== null && type !== seed.type) {
        throw new DomainError(
          Random.className,
          "constructor",
          {
            seed: {value: seed, expectedType: "seed"},
            type: {value: type, expectedType: "string"}
          },
          "A random state seed type must match the given random number generator type."
        );
      } else {
        type = seed.type;
      }
    }

    if (type === "WELL512A") {
      this.gen = new WELL512A(<number | string | null | undefined | WELL512AState>seed);
    } else if (type === "WELL1024A") {
      this.gen = new WELL1024A(<number | string | null | undefined | WELL1024AState>seed);
    } else if (type === "ARC4") {
      this.gen = new ARC4(<number | string | null | undefined | ARC4State>seed);
    } else if (typeof type === "undefined" || type === null) {
      // default
      this.gen = new WELL1024A(<number | string | null | undefined | WELL1024AState>seed);
    } else {
      throw new DomainError(
        Random.className,
        "constructor",
        {
          seed: {value: seed, expectedType: "seed"},
          type: {value: type, expectedType: "string"}
        },
        `Random number generator type must be "ARC4", "WELL512A", or "WELL1024A".`
      );
    }

    this.width = this.gen.outputWidth;
  }

  public state(): IRandomState {
    return this.gen.state();
  }

  public float(p: P): float {
    let num: int = C.I_0; Core.numberToIntUnchecked(this.gen.next());
    let denom: int = C.I_1;
    let x = 0;
    let currentLength: number;

    while ((currentLength = Bitwise.lengthI(num)) < p.binDigits) {
      num = Bitwise.orI(
        Bitwise.leftShiftI(num, this.width),
        Core.numberToIntUnchecked(this.gen.next())
      );
      denom = Bitwise.leftShiftI(denom, this.width);
    }

    const rightShiftAmount = currentLength - p.binDigits;

    if (rightShiftAmount > 0) {
      num = Bitwise.rightShiftI(num, rightShiftAmount);
      denom = Bitwise.rightShiftI(denom, rightShiftAmount);
    }

    return Basic.divideFF(
      Conversion.intToFloat(
        Basic.addII(num, Core.numberToIntUnchecked(x)),
        p,
        true
      ),
      Conversion.intToFloat(denom, p, true),
      p
    );
  }


  // class dependencies
  public static dependencies(): Set<Class> {
    return new Set([
      C, Core, Conversion, Bitwise, Basic, WELL512A, WELL1024A, ARC4, DomainError
    ]);
  }
}


// *** imports come at end to avoid circular dependency ***

// interface/type imports
import {int} from "../interfacesAndTypes/int";
import {float} from "../interfacesAndTypes/float";
import {RandomNumGen} from "../interfacesAndTypes/RandomNumGen";
import {IRandomState} from "../interfacesAndTypes/IRandomState";
import {Class} from "../interfacesAndTypes/Class";

import {P as PAlias} from "../dataTypes/P";
export type P = PAlias;


// functional imports
import {C as CAlias} from "../constants/C";
const C = CAlias;

import {Core as CoreAlias} from "../core/Core";
const Core = CoreAlias;

import {Conversion as ConversionAlias} from "../core/Conversion";
const Conversion = ConversionAlias;

import {Bitwise as BitwiseAlias} from "../basicFunctions/Bitwise";
const Bitwise = BitwiseAlias;

import {Basic as BasicAlias} from "../basicFunctions/Basic";
const Basic = BasicAlias;

import {WELL512A as WELL512AAlias, WELL512AState} from "./WELL512A";
const WELL512A = WELL512AAlias;

import {WELL1024A as WELL1024AAlias, WELL1024AState} from "./WELL1024A";
const WELL1024A = WELL1024AAlias;

import {ARC4 as ARC4Alias, ARC4State} from "./ARC4";
const ARC4 = ARC4Alias;

import {DomainError as DomainErrorAlias} from "../errors/DomainError";
const DomainError = DomainErrorAlias;



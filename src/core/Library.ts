"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


export type internalFunctionSpec = {
  name: string,
  funct: Function,
  params: Array<ParameterSpec>,
  returnType: TypeDescriptor,
  relPrec: number,
  c?: Class
}


export class Library {
  public static className: string;
  private static _classes: {[className: string]: Class};
  private static _internalFuncts:
    {[className: string]: {[functName: string]: internalFunctionSpec}};
  private static _indexFWs: {[functName: string]: FunctionWrapper};
  private static _floatMethodFWs: {[methodName: string]: FunctionWrapper};
  private static _intMethodFWs: {[methodName: string]: FunctionWrapper};

  public static init0(): void {
    Library.className = "Library";
    Library._classes = {};
    Library._internalFuncts = {};
    Library._indexFWs = {};
    Library._floatMethodFWs = {};
    Library._intMethodFWs = {};
  }

  public static registerClass(c: Class): void {
    Library._classes[c.className] = c;
  }

  public static hasClass(c: Class): boolean {
    return typeof Library._classes[c.className] !== "undefined" &&
      typeof Library._classes[c.className].className === "string";
  }

  public static hasClassName(className: string): boolean {
    return typeof Library._classes[className] !== "undefined" &&
      typeof Library._classes[className].className === "string";
  }

  public static getClass(className: string): Class {
    if (Library.hasClassName(className)) {
      return Library._classes[className];
    } else {
      throw new LibError(
        Library.className,
        "getClass",
        `Cannot get a class that is not in the library, given className: ${
          className}`
      );
    }
  }

  public static getAllClassNames(): Array<string> {
    return Object.keys(Library._classes);
  }

  public static getAllClasses(): Array<Class> {
    return Object.values(Library._classes);
  }

  public static registerInternalFunctions(
    containingClass: Class,
    libEntries: Array<internalFunctionSpec>
  ): void {
    const className = containingClass.className;

    if (typeof Library._internalFuncts[className] === "undefined") {
      Library._internalFuncts[className] = {};
    } else {
      throw new LibError(
        Library.className,
        "registerInternalFunctions",
        `Class has already registered internal functions`
      );
    }

    for (let libEntry of libEntries) {
      libEntry.c = containingClass;
      Library._internalFuncts[className][libEntry.name] = libEntry;
    }
  }

  public static hasInternalFunction(
    containingClassName: string,
    functionName: string
  ): boolean {
    return typeof Library._internalFuncts[containingClassName][functionName] !==
      "undefined";
  }

  public static getInternalFunction(
    containingClassName: string,
    functionName: string
  ): internalFunctionSpec {
    if (Library.hasInternalFunction(containingClassName, functionName)) {
      return Library._internalFuncts[containingClassName][functionName];
    } else {
      throw new LibError(
        Library.className,
        "getClass",
        `Cannot get a class that is not in the library,${""
        } given className: ${containingClassName}, function name: ${functionName}.`
      );
    }
  }

  public static registerIndexFW(fw: FunctionWrapper): void {
    Library._indexFWs[fw.name] = fw;
  }

  public static hasIndexFW(functionName: string): boolean {
    return typeof Library._indexFWs[functionName] !== "undefined";
  }

  public static getIndexFW(functionName: string): FunctionWrapper {
    if (Library.hasIndexFW(functionName)) {
      return Library._indexFWs[functionName];
    } else {
      throw new LibError(
        Library.className,
        "getIndexFW",
        `Cannot get an index function Function Wrapper that is not in the${""
          } library, given functionName: ${functionName}.`
      );
    }
  }

  public static getAllIndexFunctionNames(): Array<string> {
    return Object.keys(Library._indexFWs);
  }

  public static getAllIndexFWs(): Array<FunctionWrapper> {
    return Object.values(Library._indexFWs);
  }

  public static registerFloatMethodFW(fw: FunctionWrapper): void {
    Library._floatMethodFWs[fw.name] = fw;
  }

  public static hasFloatMethodFW(methodName: string): boolean {
    return typeof Library._floatMethodFWs[methodName] !== "undefined";
  }

  public static getFloatMethodFW(methodName: string): FunctionWrapper {
    if (Library.hasFloatMethodFW(methodName)) {
      return Library._floatMethodFWs[methodName];
    } else {
      throw new LibError(
        Library.className,
        "getFloatMethodFW",
        `Cannot get a Float method Function Wrapper that is not in the${""
        } library, given methodName: ${methodName}.`
      );
    }
  }

  public static getAllFloatMethodNames(): Array<string> {
    return Object.keys(Library._floatMethodFWs);
  }

  public static getAllFloatMethodFWs(): Array<FunctionWrapper> {
    return Object.values(Library._floatMethodFWs);
  }

  public static registerIntMethodFW(fw: FunctionWrapper): void {
    Library._intMethodFWs[fw.name] = fw;
  }

  public static hasIntMethodFW(methodName: string): boolean {
    return typeof Library._intMethodFWs[methodName] !== "undefined";
  }

  public static getIntMethodFW(methodName: string): FunctionWrapper {
    if (Library.hasIntMethodFW(methodName)) {
      return Library._intMethodFWs[methodName];
    } else {
      throw new LibError(
        Library.className,
        "getIntMethodFW",
        `Cannot get a Int method Function Wrapper that is not in the${""
          } library, given methodName: ${methodName}.`
      );
    }
  }

  public static getAllIntMethodFWs(): Array<FunctionWrapper> {
    return Object.values(Library._intMethodFWs);
  }

  public static getAllIntMethodNames(): Array<string> {
    return Object.keys(Library._intMethodFWs);
  }


  public static dependencies(): Set<Class> {
    return new Set([
      LibError, LibEntryInternal
    ]);
  }
}


// *** imports come at end to avoid circular dependency ***

// interface/type imports
import {Class} from "../interfacesAndTypes/Class";
import {ParameterSpec} from "../interfacesAndTypes/ParameterSpecs/ParameterSpec";
import {TypeDescriptor} from "../interfacesAndTypes/TypeDescriptor";

import {FunctionWrapper as FunctionWrapperAlias} from
    "../outward/functionWrapping/FunctionWrapper";
type FunctionWrapper = FunctionWrapperAlias;

// functional imports
import {LibError as LibErrorAlias} from "../errors/LibError";
const LibError = LibErrorAlias;

import {LibEntryInternal as LibEntryInternalAlias} from
    "../dataTypes/LibEntryInternal";
const LibEntryInternal = LibEntryInternalAlias;
type LibEntryInternal = LibEntryInternalAlias;


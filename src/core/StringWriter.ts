"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

// interface imports
import {int} from "../interfaces/int";
import {float} from "../interfaces/float";

// functional imports
import {Integer as IntegerAlias} from "../dataTypes/Integer";
const Integer = IntegerAlias;

import {Float as FloatAlias} from "../dataTypes/Float";
const Float = FloatAlias;

import {C as CAlias} from "../constants/C";
const C = CAlias;

import {Sign as SignAlias} from "../basicFunctions/Sign";
const Sign = SignAlias;

import {Comparison as ComparisonAlias} from "../basicFunctions/Comparison";
const Comparison = ComparisonAlias;

import {Core as CoreAlias} from "./Core";
const Core = CoreAlias;

import {Basic as BasicAlias} from "../basicFunctions/Basic";
const Basic = BasicAlias;

import {Conversion as ConversionAlias} from "./Conversion";
const Conversion = ConversionAlias;

import {Power as PowerAlias} from "../basicFunctions/Power";
const Power = PowerAlias;

import {Log as LogAlias} from "../basicFunctions/Log";
const Log = LogAlias;

import {P as PAlias} from "./P";
const P = PAlias;
export type P = PAlias;


export class StringWriter {

  // class constants
  public static EXTREME_EXPONENT: int;
  public static LARGE_INTEGER_LENGTH: number;
  public static NaN_STRING: string;
  public static POSITIVE_INFINITY_STRING: string;
  public static NEGATIVE_INFINITY_STRING: string;
  public static RADIX_POINT_STRING: string;

  public static setStaticProperties(): void {
    StringWriter.EXTREME_EXPONENT = new Integer(false, Uint32Array.of(10000));
    StringWriter.LARGE_INTEGER_LENGTH = 1000;
    StringWriter.NaN_STRING = "NaN";
    StringWriter.POSITIVE_INFINITY_STRING = "infinity";
    StringWriter.NEGATIVE_INFINITY_STRING = "-infinity";
    StringWriter.RADIX_POINT_STRING = ".";
  }

  public readonly sign: "-" | "";
  public readonly type: "finite" | "infinite" | "NaN";
  public readonly base: number;
  public readonly coefRadix: number;
  public readonly expRadix: number;
  public readonly precision: number;
  public readonly coef: Array<number>;
  public readonly coefDigitsBeforeRadixPoint: number;
  public readonly exp: int;

  constructor(
    val: int | float,
    base: number,
    coefficientRadix: number,
    exponentRadix: number,
    precision: number
  ){
    this.base = base;
    this.coefRadix = coefficientRadix;
    this.expRadix = exponentRadix;

    if (Core.instanceI(val)) {
      if (Comparison.isFiniteI(val)) {
        this.sign = Comparison.isNegativeI(val) ? "-" : "";
        this.type = "finite";

        if (Comparison.isZeroI(val)) {
          this.coef = [0];
          this.coefDigitsBeforeRadixPoint = 1;
          this.exp = C.I_0;
          this.coefDigitsBeforeRadixPoint = 1;
          this.sign = "";
        } else {
          if (val.digits.length <= StringWriter.LARGE_INTEGER_LENGTH
            && base === coefficientRadix) {
            const coefDigits = StringWriter.changeIntRadix(val, coefficientRadix);
            this.exp = Core.numberToInt(coefDigits.length - 1);

            if (precision < 1) { // default precision for ints is full precision
              precision = coefDigits.length;
            }
            this.precision = precision;

            if (coefDigits.length > precision) {
              const round = StringWriter.roundDigitArray(
                coefDigits,
                coefficientRadix,
                precision
              );
              this.coef = round.result;
              this.exp = Basic.addII(this.exp, round.expAdjustment);
            } else {
              this.coef = coefDigits;
            }
            this.coefDigitsBeforeRadixPoint = 1;
          } else {
            let prec: P;

            if (precision < 1) { // default precision for ints is full precision
              prec = P.createPFromNumDigits(val.digits.length);
            } else {
              prec = StringWriter.getPFromPrecision(precision, coefficientRadix);
            }

            const valFloat = Conversion.intToFloat(val, prec);
            const sciNote = StringWriter.sciNote(valFloat, base, prec);
            this.exp = sciNote.exponent;

            if (precision < 1) { // default precision for ints is full precision
              precision = Core.intToNumber(sciNote.exponent) + 1;
            }
            this.precision = precision;

            const coefDigits = StringWriter.convertSciNoteCoefToDigitArray(
              sciNote,
              precision,
              coefficientRadix,
              prec
            );

            this.coef = coefDigits.result;
            this.coefDigitsBeforeRadixPoint = coefDigits.digitsBeforeRadixPoint;
          }
        }
      } else if (Comparison.isPOSITIVE_INFINITY_I(val)) {
        this.sign = "";
        this.type = "infinite";
      } else if (Comparison.isNEGATIVE_INFINITY_I(val)) {
        this.sign = "-";
        this.type = "infinite";
      } else { // val = NaN
        this.type = "NaN";
      }
    } else {
      if (Comparison.isFinite(val)) {
        if (Comparison.isZero(val)) {
          this.coef = [0];
          this.coefDigitsBeforeRadixPoint = 1;
          this.exp = C.I_0;
          this.coefDigitsBeforeRadixPoint = 1;
          this.sign = "";
        } else {
          this.sign = Comparison.isNegative(val) ? "-" : "";
          this.type = "finite";

          if (precision < 1) {
            precision = StringWriter.defaultPrecisionFloat(coefficientRadix);
          }
          this.precision = precision;
          const prec = StringWriter.getPFromPrecision(precision, coefficientRadix);
          const sciNote = StringWriter.sciNote(val, base, prec);

          this.exp = sciNote.exponent;

          const coefDigits = StringWriter.convertSciNoteCoefToDigitArray(
            sciNote,
            precision + 1,
            coefficientRadix,
            prec
          );

          this.coefDigitsBeforeRadixPoint = coefDigits.digitsBeforeRadixPoint;

          const round = StringWriter.roundDigitArray(
            coefDigits.result,
            coefficientRadix,
            precision
          );
          this.coef = round.result;
          this.exp = Basic.addII(this.exp, round.expAdjustment);
        }
      } else if (Comparison.isPOSITIVE_INFINITY(val)) {
        this.sign = "";
        this.type = "infinite";
      } else if (Comparison.isNEGATIVE_INFINITY(val)) {
        this.sign = "-";
        this.type = "infinite";
      } else { // val = NaN
        this.type = "NaN";
      }
    }
  }

  private get baseString(): string {
    if (this.base === 10) {
      return "e";
    } else if (this.base === 2) {
      return "p";
    } else {
      return `x${this.base}^`;
    }
  }

  private toStandardNotationUnchecked(
    removeTrailingFractionalZeros: boolean,
    radixPointPosition: number
  ): string {
    const digits = !removeTrailingFractionalZeros && this.precision > this.coef.length ?
      this.coef.concat(Array(this.precision - this.coef.length).fill(0))
      :
      this.coef;
    let digitsBeforePoint: number[];
    let digitsAfterPoint: number[];

    if (radixPointPosition < 0) {
      digitsBeforePoint = [0];
      digitsAfterPoint = Array(-radixPointPosition).fill(0).concat(digits);
    } else if (radixPointPosition === 0) {
      digitsBeforePoint = [0];
      digitsAfterPoint = digits;
    } else if (radixPointPosition < digits.length) {
      digitsBeforePoint = digits.slice(0, radixPointPosition);
      digitsAfterPoint = digits.slice(radixPointPosition);
    } else if (radixPointPosition === this.coef.length) {
      digitsBeforePoint = digits;
      digitsAfterPoint = [];
    } else { // radixPointPosition > this.coef.length
      digitsBeforePoint = digits
        .concat(Array(radixPointPosition - this.coef.length).fill(0));
      digitsAfterPoint = [];
    }

    let result = this.sign + digitsBeforePoint
      .map(d => d.toString(this.coefRadix))
      .join("");

    if (digitsAfterPoint.length > 0) {
      result += StringWriter.RADIX_POINT_STRING + digitsAfterPoint
        .map(d => d.toString(this.coefRadix))
        .join("");
    }

    if (this.coefRadix > 10) {
      result = result.toUpperCase();
    }

    return result;
  }

  private get expString(): string {
    if (Comparison.gtI(Sign.absI(this.exp), C.NUMBER_MAX_SAFE_INTEGER)) {
      const digits = StringWriter.changeIntRadix(this.exp, this.coefRadix);
      const absExpStr = digits
        .map(d => d.toString(this.coefRadix))
        .join("");

      let signStr: string;

      if (Comparison.isPositiveI(this.exp)) {
        signStr = "+";
      } else if (Comparison.isNegativeI(this.exp)) {
        signStr = "-";
      } else {
        signStr = "";
      }

      return signStr + absExpStr;
    } else {
      const expNum = Core.intToNumber(this.exp);
      const result = expNum.toString(this.coefRadix);


      return expNum > 0 ? "+" + result : result;
    }
  }

  public toScientificNotation(removeTrailingFractionalZeros: boolean): string {
    // const negative: boolean = StringWriter.EMD.isNegativeV(x);
    // const sign = negative ? "-" : "";

    if (this.type === "infinite") {
      return this.sign === "-" ?
        StringWriter.NEGATIVE_INFINITY_STRING
        :
        StringWriter.POSITIVE_INFINITY_STRING
    } else if (this.type === "NaN") {
      return StringWriter.NaN_STRING;
    } else {
      return this.toStandardNotationUnchecked(
        removeTrailingFractionalZeros,
        this.coefDigitsBeforeRadixPoint
      ) + this.baseString + this.expString;
    }
  }

  public toStandardNotation(removeTrailingFractionalZeros: boolean): string {
    if (this.type === "infinite") {
      return this.sign === "-" ?
        StringWriter.NEGATIVE_INFINITY_STRING
        :
        StringWriter.POSITIVE_INFINITY_STRING
    } else if (this.type === "NaN") {
      return StringWriter.NaN_STRING;
    } else {
      return this.toStandardNotationUnchecked(
        removeTrailingFractionalZeros,
        Core.intToNumber(this.exp) + 1
      );
    }
  }

  public static defaultPrecisionFloat(coefficientRadix: number): number {
    if (coefficientRadix === 2) {
      return P.p.binaryDigits;
    } else if (coefficientRadix === 10) {
      return P.p.decimalDigits;
    } else {
      return Math.ceil(Core.logWithBase(coefficientRadix, 2) * P.p.binaryDigits);
    }
  }

  public static getPFromPrecision(precision: number, coefficientRadix: number): P {
    return P.createPFromNumDigits(Math.ceil(
      precision * Core.logWithBase(C.BASE, coefficientRadix
      )) + 1
    );
  }

  /**
   * @param {int} a - an int
   * @param {number} radix - an integer number >= 2
   * @returns {Array<number>}
   */
  public static changeIntRadix(a: int, radix: number): Array<number> {
    if (Comparison.isZeroI(a)) {
      return [0];
    }

    const radixInt = Core.numberToIntUnchecked(radix);
    let rest = Sign.absI(a);
    const digits: number[] = [];
    let div: {q: int, r: int};

    while(Comparison.isPositiveI(rest)) {
      div = Basic.divideII(rest, radixInt);
      digits.unshift(Core.intToNumber(div.r));
      rest = div.q;
    }

    return digits;
  }

  /**
   * This function returns a coefficient and exponent such that:
   *
   *          x = coefficient * (base ^ exponent)
   *
   * @param {float} x - a finite non-zero float
   * @param {number} base - a positive integer number
   * @param {P} prec
   * @returns {{coefficient: float, exponent: int}}
   */
  public static sciNote(
    x: float,
    base: number,
    prec: P
  ): {coefficient: float, exponent: int} {
    if (base === C.BASE) {
      return {
        coefficient: new Float(x.coef, C.I_0),
        exponent: x.exp
      }
    } else {
      const baseFloat = Core.numberToFloatUnchecked(base);
      let exponentFloat: float;

      if (Comparison.lteI(Sign.absI(x.exp), C.NUMBER_MAX_SAFE_INTEGER)) {
        exponentFloat = Basic.addFF(
          Core.numberToFloatUnchecked(Core.logWithBase(base, x.coef.digits[0])),
          Basic.multiplyFF(
            Conversion.intToFloat(x.exp, prec),
            Core.numberToFloatUnchecked(
              Core.logWithBase(base, 2) * C.POWER_OF_TWO_FOR_BASE
            ),
            prec
          ),
          prec
        );
      } else {
        exponentFloat = Log.baseFF(
          x,
          baseFloat,
          P.createPFromNumDigits(x.exp.digits.length))
      }

      // exponentFloat is probably not an integer yet, so floor it
      let exponent = Conversion.floatToInt(exponentFloat, "floor");
      exponentFloat = Conversion.intToFloat(
        exponent,
        P.createPFromNumDigits(exponent.digits.length),
        true
      );
      const baseToExponent: float = Power.ff(baseFloat, exponentFloat, prec);
      let coefficient = Basic.divideFF(x, baseToExponent, prec);

      // we want to make sure that the exponent level is set so that
      // 1 <= |coefficient| < base, rounding errors may have occurred in the calculation
      // of the exponent
      let absCoef = Sign.absF(coefficient);

      while (Comparison.gte(absCoef, baseFloat)) {
        exponent = Basic.addII(exponent, C.I_1);
        coefficient = Basic.divideFF(coefficient, baseFloat, prec);
        absCoef = Sign.absF(coefficient);
      }

      while (Comparison.lt(absCoef, C.F_1)) {
        exponent = Basic.addII(exponent, C.I_NEG_1);
        coefficient = Basic.multiplyFF(coefficient, baseFloat, prec);
        absCoef = Sign.absF(coefficient);
      }

      return {exponent: exponent, coefficient: coefficient};
    }
  }

  public static splitIntNumToDigits(
    chunk: number,
    radix,
    fillout: boolean,
    chunkSize: number
  ): number[] {
    let result = Math.abs(chunk)
      .toString(radix)
      .split("")
      .map((d) => parseInt(d, radix));

    if (fillout && result.length < chunkSize) {
      return Array(chunkSize - result.length).fill(0).concat(result);
    } else {
      return result;
    }
  }

  public static convertSciNoteCoefToDigitArray(
    sciNote: {coefficient: float, exponent: int},
    precision: number,
    radix: number,
    prec?: P
  ): {result: number[], digitsBeforeRadixPoint: number} {
    // Note that the correctness of this algorithm depends on: 2 <= radix <= 36 and
    // 0 <= chunkSize <= 10 and radix and chunkSize are both integers so
    // 1 <= Math.pow(radix, chuckSize) <= 3656158440062976 < Number.MAX_SAFE_INTEGER
    if (!prec) { prec = P.p; }

    const maxChunkSize: number = prec.numDigits > 2 ? 10 : 5;
    let chunkSize = Math.min(precision - 1, maxChunkSize);
    let radixToChunkSizePow: float = Core.numberToFloat(Math.pow(radix, chunkSize));
    let result: number[] = [];
    let x: float = Sign.absF(sciNote.coefficient);
    let chunk: number;
    let digits: number[];
    let digitsLeft = precision;
    let beforeRadixPoint: boolean = true;
    let digitsBeforeRadixPoint: number = -1;


    while (digitsLeft > 0) {
      if (Comparison.isZero(x)) {
        if (result.length === 0) {
          result = [0];
        }
        break;
      }

      chunk = Core.floatToNumber(Conversion.trunc(x));
      digits = StringWriter.splitIntNumToDigits(
        chunk,
        radix,
        !beforeRadixPoint,
        chunkSize
      );

      if (beforeRadixPoint) {
        digitsBeforeRadixPoint = digits.length;
        beforeRadixPoint = false;
      }

      // TODO: remove this error checking or fill out with handling code if necessary;
      for (let digit of digits) {
        if (digit >= radix) {
          throw new Error(`(digit = ${digit})  >= (radix = ${radix})`)
        } else if (digit < 0) {
          throw new Error(`(digit = ${digit}) < 0`);
        }
      }
      // end of code for removal or modification

      result = result.concat(digits);
      digitsLeft -= digits.length;

      if (chunkSize > digitsLeft) {
        chunkSize = digitsLeft;
        radixToChunkSizePow = Core.numberToFloat(Math.pow(radix, chunkSize));
      }


      x = Basic.multiplyFF(
        Basic.subtractFF(x, Core.numberToFloatUnchecked(chunk), prec),
        radixToChunkSizePow,
        prec
      );
    }

    // remove trailing zeros or possibly too many digits
    while((result.length > 1 && result[result.length - 1] === 0)
    || result.length > precision) {
      result.pop();
    }

    return {result: result, digitsBeforeRadixPoint: digitsBeforeRadixPoint};
  }

  private static roundDigitArray(
    digitArray: number[],
    radix: number,
    finalLength: number
  ): {result: number[], expAdjustment: int} {
    let result: number[];
    let expAdjustment: int = C.I_0;
    const finalDigitIndex = finalLength - 1;

    if (finalDigitIndex < 0 || finalDigitIndex >= digitArray.length - 1) {
      return {result: digitArray, expAdjustment: C.I_0};
    }

    const radixMinus1 = radix - 1;
    const firstCutDigit = digitArray[finalLength];
    const finalDigit = firstCutDigit >= radix/2 ?
      digitArray[finalDigitIndex] + 1
      :
      digitArray[finalDigitIndex];

    if (finalDigit === radix) {
      // find the index where rounding stops
      let i = finalDigitIndex - 1;
      while (i >= 0 && digitArray[i] === radixMinus1) { i--; }

      if (i === -1) {
        result = [1];
        expAdjustment = C.I_1;
      } else {
        result = digitArray.slice(0, i + 1);
        result[i]++;
      }
    } else {
      result = digitArray.slice(0, finalLength);
      result[finalDigitIndex] = finalDigit;
    }

    return {result: result, expAdjustment: expAdjustment};
  }

  public static toStr(
    val: int | float,
    radix?: number | null | undefined,
    maxPrecision?: number | null | undefined,
  ): string {
    if (typeof radix === "undefined" || radix === null) {
      radix = 10;
    }

    if (typeof maxPrecision === "undefined" || maxPrecision === null) {
      maxPrecision = -1;
    }

    const maxExpForStdNote = Core.numberToIntUnchecked(Math.ceil(
      Core.logWithBase(radix, 1e17)
    ));
    const minExpForStdNote = C.I_NEG_4;

    const sw = new StringWriter(val, radix, radix, radix, maxPrecision);

    const useSciNote =
      (radix === 10
        && (Comparison.gtI(sw.exp, maxExpForStdNote)
          || Comparison.ltI(sw.exp, minExpForStdNote)
        )
      ) || Comparison.gtI(sw.exp, StringWriter.EXTREME_EXPONENT)
      || Comparison.ltI(sw.exp, Sign.negateI(StringWriter.EXTREME_EXPONENT));

    return useSciNote ?
      sw.toScientificNotation(true)
      :
      sw.toStandardNotation(true);
  }

  public static toStandardNotation(
    val: int | float,
    radix?: number | null | undefined,
    precision?: number | null | undefined,
    removeTrailingFractionalZeros?: boolean
  ): string {
    if (typeof radix === "undefined" || radix === null) {
      radix = 10;
    }
    if (typeof removeTrailingFractionalZeros === "undefined"
      ||removeTrailingFractionalZeros === null) {
      removeTrailingFractionalZeros = !precision;
    }
    if (typeof precision === "undefined" || precision === null) {
      precision = -1;
    }

    const sw = new StringWriter(val, radix, radix, radix, precision);

    if (Comparison.gtI(sw.exp, StringWriter.EXTREME_EXPONENT)
      || Comparison.ltI(sw.exp, Sign.negateI(StringWriter.EXTREME_EXPONENT))) {
      throw new Error(
        `Val exponent is too extreme for standard notation string formation: ${
          sw.expString}, when the |limit| is ${StringWriter.EXTREME_EXPONENT.digits[0]}`
      );
    }

    return sw.toStandardNotation(removeTrailingFractionalZeros);
  }

  public static toScientificNotation(
    val: int | float,
    precision?: number | null | undefined,
    removeTrailingFractionalZeros?: boolean | null | undefined,
    coefficientRadix?: number | null | undefined,
    base?: number | null | undefined,
    exponentRadix?: number | null | undefined
  ): string {
    if (typeof removeTrailingFractionalZeros === "undefined"
      || removeTrailingFractionalZeros === null) {
      removeTrailingFractionalZeros = !precision;
    }
    if (typeof coefficientRadix === "undefined" || coefficientRadix === null) {
      coefficientRadix = 10;
    }
    if (typeof precision === "undefined" || precision === null) {
      precision = -1;
    }
    if (typeof base === "undefined" || base === null) {
      base = 10;
    }
    if (typeof exponentRadix === "undefined" || exponentRadix === null) {
      exponentRadix = 10;
    }

    const sw = new StringWriter(val, base, coefficientRadix, exponentRadix, precision);

    return sw.toScientificNotation(removeTrailingFractionalZeros);
  }
}
"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


export class StringParser {
  // class constants
  public static className: string;
  public static DEC_NUM_REGEX: RegExp;
  public static BIN_NUM_REGEX: RegExp;
  public static OCT_NUM_REGEX: RegExp;
  public static HEX_NUM_REGEX: RegExp;
  public static NAN_REGEX: RegExp;
  public static INFINITY_REGEX: RegExp;
  public static ALL_ZEROS: RegExp;

  public static init0(): void {
    StringParser.className = "StringParser";
    StringParser.DEC_NUM_REGEX =
      /^([\s\-+]*)(\d*)(?:\.(\d*))?\s*(?:([eEpP])([\s\-+]*)(\d+))?\s*$/;
    StringParser.BIN_NUM_REGEX =
      /^([\s\-+]*)0(?:[bB])([01]*)(?:\.([01]*))?\s*(?:([eEpP])([\s\-+]*)(\d+))?\s*$/;
    StringParser.OCT_NUM_REGEX =
      /^([\s\-+]*)0(?:[oO])([0-7]*)(?:\.([0-7]*))?\s*(?:([eEpP])([\s\-+]*)(\d+))?\s*$/;
    StringParser.HEX_NUM_REGEX =
      /^([\s\-+]*)0(?:[xX])([0-9a-fA-F]*)(?:\.([0-9a-fA-F]*))?\s*(?:([#pP])([\s\-+]*)(\d+))?\s*$/;
    StringParser.NAN_REGEX = /^\s*nan\s*$/i;
    StringParser.INFINITY_REGEX = /^([\s\-+]*)infinity\s*$/i;
    StringParser.ALL_ZEROS = /^0+$/;
  }

  private readonly str: string;
  private readonly type: "finite" | "infinite" | "NaN";
  private readonly negative: boolean;
  private readonly sigStrWithoutRadixPoint: string;
  private readonly numDigitsBeforeRadixPointInSignificand: number;
  private readonly exponent: int;
  private readonly base: int;
  private readonly coefficientRadix: number;
  private _int: int;

  constructor(str: string) {
    this.str = str;
    let match;

    if (StringParser.NAN_REGEX.test(str)) {  // number parses to NaN (not a number)
      this.type = "NaN";
      this._int = C.NaN;
      return;
    } else if (match = str.match(StringParser.INFINITY_REGEX)) { // parses to +/- infinity
      this.type = "infinite";
      this.negative = StringParser.signStringIsNegative(match[1]);
      this._int = this.negative ? C.NEGATIVE_INFINITY : C.POSITIVE_INFINITY;
      return;
    } else if (match = str.match(StringParser.DEC_NUM_REGEX)) {
      this.coefficientRadix = 10;
    } else if (match = str.match(StringParser.BIN_NUM_REGEX)) {
      this.coefficientRadix = 2;
    } else if (match = str.match(StringParser.OCT_NUM_REGEX)) {
      this.coefficientRadix = 8;
    } else if (match = str.match(StringParser.HEX_NUM_REGEX)) {
      this.coefficientRadix = 16;
    } else {
      throw new ConversionError(
        StringParser.className,
        "constructor",
        "str",
        "string",
        "float or int",
        str
      );
    }

    this.type = "finite";
    this.negative = StringParser.signStringIsNegative(match[1]);
    const significandDigitsBeforeRadixPoint = match[2];
    const significandDigitsAfterRadixPoint =
      match[3] && !StringParser.ALL_ZEROS.test(match[3])? match[3] : "";
    this.sigStrWithoutRadixPoint =
      significandDigitsBeforeRadixPoint + significandDigitsAfterRadixPoint;

    if (this.sigStrWithoutRadixPoint.length <= 0) {
      throw new ConversionError(
        StringParser.className,
        "constructor",
        "str",
        "string",
        "float or int",
        str
      );
    }

    this.numDigitsBeforeRadixPointInSignificand =
      significandDigitsBeforeRadixPoint.length;
    const baseStr = match[4];
    const exponentSignStr = match[5];
    const exponentStr = match[6];

    if (typeof baseStr === "string") {
      if (baseStr.toUpperCase() === "P") {
        this.base = C.I_2;
      } else {
        this.base = C.I_10;
      }
      const negativeExponent = StringParser.signStringIsNegative(exponentSignStr);
      const exponentAbsVal = StringParser.parseSimpleNonnegativeIntString(
        exponentStr,
        10
      );
      this.exponent = negativeExponent ? Sign.negateI(exponentAbsVal) : exponentAbsVal;
    } else {
      this.exponent = C.I_0;
      this.base = C.I_1;
    }

    return;
  }

  get int(): int {
    if (!this._int) {
      const numSignificandDigits = this.sigStrWithoutRadixPoint.length;
      const numSignificandRadixPlaces =
        numSignificandDigits - this.numDigitsBeforeRadixPointInSignificand;
      let val = StringParser.parseSimpleNonnegativeIntString(
        this.sigStrWithoutRadixPoint,
        this.coefficientRadix
      );

      if (!Comparison.isZeroI(this.exponent)) {
        val = Basic.multiplyII(val, Pow.ii(this.base, this.exponent));
      }

      if (numSignificandRadixPlaces !== 0) {
        const divResult = Basic.divideII(
          val,
          Pow.ii(
            Core.numberToInt(this.coefficientRadix),
            Core.numberToInt(numSignificandRadixPlaces)
          ),
          "trunc"
        );

        if (!Comparison.isZeroI(divResult.remainder)) {
          throw new ConversionError(
            StringParser.className,
            "int get method",
            "str",
            "string",
            "int",
            this.str
          );
        }


        val = divResult.quotient;
      }

      if (this.negative && !Comparison.isZeroI(val)) {
        this._int = Sign.negateI(val);
      } else {
        this._int = val;
      }
    }

    return this._int;
  }

  public float(p: P): float {
    if (this.type === "finite") {
      const numSignificandDigits = this.sigStrWithoutRadixPoint.length;
      const numSignificandRadixPlaces =
        numSignificandDigits - this.numDigitsBeforeRadixPointInSignificand;
      let val = Conversion.intToFloat(StringParser.parseSimpleNonnegativeIntString(
        this.sigStrWithoutRadixPoint,
        this.coefficientRadix
      ), p, false);

      if (!Comparison.isZeroI(this.exponent)) {
        val = Basic.multiplyFF(
          val,
          Pow.fi(
            Conversion.intToFloat(this.base, p, false),
            this.exponent,
            p
          ),
          p
        );
      }

      if (numSignificandRadixPlaces !== 0) {
        val = Basic.divideFF(
          val,
          Pow.fi(
            Core.numberToFloat(this.coefficientRadix),
            Core.numberToInt(numSignificandRadixPlaces),
            p
          ),
          p
        );
      }

      val = this.negative && !Comparison.isZero(val) ? Sign.negateF(val) : val;

      // now check if we can't do better by just parsing to a number and using that number
      // in the value, this is especially true when the string value can be exactly
      // represented by a JavaScript number
      const numParsingFloat: float = Core.numberToFloat(parseFloat(this.str));
      const relDiff: float = Diff.relativeFF(numParsingFloat, val, p);

      if (Comparison.lt(relDiff, p.epsilon)) {
        // number parsing seems to be better
        return numParsingFloat;
      } else {
        // float parsing is better representation of string value
        return val;
      }
    } else if (this.type === "infinite") {
      return this.negative ? C.F_NEGATIVE_INFINITY : C.F_POSITIVE_INFINITY;
    } else { // this.type === "NaN"
      return C.F_NaN;
    }
  }




  private static signStringIsNegative(signStr: string): boolean {
    return signStr.replace(/[\s+]/g, "").length % 2 === 1;
  }

  /**
   * This function parses a string of digit characters into an int
   * @param {string} str - a string of digit characters with no sign or decimal point
   * characters
   * @param {number} radix - the radix of the digit characters between 2 and 36
   */
  private static parseSimpleNonnegativeIntString(str: string, radix: number): int {
    // Note that the correctness of this algorithm depends on: 2 <= radix <= 36 and
    // 0 <= chunkSize <= 10 and radix and chunkSize are both integers so
    // 1 <= Math.pow(radix, chuckSize) <= 3656158440062976 < Number.MAX_SAFE_INTEGER
    let value: int = C.I_0;
    let index: number = 0;
    let newIndex: number;
    let chunkSize: number = 10;
    let chunk: string;
    let chunkInt: int;
    let strLengthMinusIndex: number;
    let radixToChunkSizePower: int = Core.numberToInt(Math.pow(radix, chunkSize));

    do {
      strLengthMinusIndex = str.length - index;
      if (strLengthMinusIndex < chunkSize) {
        chunkSize = strLengthMinusIndex;
        radixToChunkSizePower = Core.numberToInt(Math.pow(radix, chunkSize));
      }
      newIndex = index + chunkSize;
      chunk = str.slice(index, newIndex);
      index = newIndex;
      chunkInt = Core.numberToInt(parseInt(chunk, radix));
      value = Basic.multiplyII(value, radixToChunkSizePower);
      value = Basic.addII(value, chunkInt);

    } while (str.length > index);

    return value;
  }


  // class dependencies
  public static dependencies(): Set<Class> {
    return new Set([
      C, Sign, Comparison, Basic, Pow, Core, Conversion, Diff, ConversionError,
    ]);
  }
}


// *** imports come at end to avoid circular dependency ***

// interface/type imports
import {int} from "../interfaces/int";
import {float} from "../interfaces/float";
import {Class} from "../interfaces/Class";

import {P as PAlias} from "../dataTypes/P";
export type P = PAlias;


// functional imports
import {C as CAlias} from "../constants/C";
const C = CAlias;

import {Sign as SignAlias} from "../basicFunctions/Sign";
const Sign = SignAlias;

import {Comparison as ComparisonAlias} from "../basicFunctions/Comparison";
const Comparison = ComparisonAlias;

import {Basic as BasicAlias} from "../basicFunctions/Basic";
const Basic = BasicAlias;

import {Pow as PowAlias} from "../basicFunctions/Pow";
const Pow = PowAlias;

import {Core as CoreAlias} from "./Core";
const Core = CoreAlias;

import {Conversion as ConversionAlias} from "./Conversion";
const Conversion = ConversionAlias;

import {Diff as DiffAlias} from "../basicFunctions/Diff";
const Diff = DiffAlias;

import {ConversionError as ConversionErrorAlias} from "../errors/ConversionError";
const ConversionError = ConversionErrorAlias;



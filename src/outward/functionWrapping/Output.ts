"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


export type OutputFunction = (val: any, config: Configuration) => any;
export type OutputFunctionGen = (fw: FunctionWrapper) => OutputFunction;


export class Output {
  public static className: string;

  public static init0(): void {
    Output.className = "Output";
  }

  public static getOutputValuesForExternalFunct(
    internalFunctionSpec: internalFunctionSpec
  ): { returnType: TypeDescriptor, outputFunctGen: OutputFunctionGen | null } {
    let returnType: TypeDescriptor;
    let outputFunctionGen: OutputFunctionGen | null;

    switch(internalFunctionSpec.returnType) {
      case "string":
      case "JSONFloat":
      case "JSONInt":
        returnType = "string";
        outputFunctionGen = null;
        break;
      case "number":
        returnType = "number";
        outputFunctionGen = null;
        break;
      case "boolean":
        returnType = "boolean";
        outputFunctionGen = null;
        break;
      case "float":
        returnType = "Float";
        outputFunctionGen = Output.getFloatOutputFunction;
        break;
      case "int":
        returnType = "Int";
        outputFunctionGen = Output.getIntOutputFunction;
        break;
      case "IntDivResult":
        returnType = "IntDivResult";
        outputFunctionGen = Output.getIntDivisionResultOutputFunction;
        break;
      case "FloatDivResult":
        returnType = "FloatDivResult";
        outputFunctionGen = Output.getFloatDivisionResultOutputFunction;
        break;
      default:
        throw new LibError(
          "Output",
          "constructor",
          `Unrecognized return type, given: ${internalFunctionSpec.returnType}.`
        );
    }

    return {returnType: returnType, outputFunctGen: outputFunctionGen};
  }

  private static getFloatOutputFunction(
    fw: FunctionWrapper
  ): (x: float, config: Configuration) => Float {
    return (x: float, config: Configuration): Float => {
      // First, check for an infinite result and in that case whether an error should be
      // thrown according to configuration
      if ((Comparison.isPOSITIVE_INFINITY(x) || Comparison.isNEGATIVE_INFINITY(x)) &&
        config.onInfiniteOutput === "throw error") {
        // TODO fill out with infinite result error;
      }

      // next, if x is of too high a precision slice it down
      const xSlice = PREC.sliceToP(x, Configuration.getP(config));

      // finally wrap the result float in a Float
      return FloatUtil.createFloat(xSlice);
    }
  }

  private static getIntOutputFunction(
    fw: FunctionWrapper
  ): (a: int, config: Configuration) => Int {
    return (a: int, config: Configuration): Int => {
      // First, check for an infinite result and in that case whether an error should be
      // thrown according to configuration
      if ((Comparison.isPOSITIVE_INFINITY_I(a) || Comparison.isNEGATIVE_INFINITY_I(a)) &&
        config.onInfiniteOutput === "throw error") {
        // TODO fill out with infinite result error;
      }

      // finally wrap the result int in an Int
      return IntUtil.createInt(a);
    }
  }

  private static getFloatDivisionResultOutputFunction(
    fw: FunctionWrapper
  ): (
    val: FloatDivisionResult,
    config: Configuration
  ) => {quotient: Float, remainder: Float} {
    return (
      val: FloatDivisionResult,
      config: Configuration
    ): {quotient: Float, remainder: Float} => {
      // First, check for an infinite result and in that case whether an error should be
      // thrown according to configuration
      if ((Comparison.isPOSITIVE_INFINITY(val.quotient) ||
        Comparison.isNEGATIVE_INFINITY(val.quotient)) &&
        config.onInfiniteOutput === "throw error") {
        // TODO fill out with infinite result error;
      }

      if ((Comparison.isPOSITIVE_INFINITY(val.remainder) ||
        Comparison.isNEGATIVE_INFINITY(val.remainder)) &&
        config.onInfiniteOutput === "throw error") {
        // TODO fill out with infinite result error;
      }

      // next, if quotient or remainder is of too high a precision slice them down
      const qSlice = PREC.sliceToP(val.quotient, Configuration.getP(config));
      const rSlice = PREC.sliceToP(val.remainder, Configuration.getP(config));

      // finally wrap quotient and remainder in Floats
      return {
        quotient: FloatUtil.createFloat(qSlice),
        remainder: FloatUtil.createFloat(rSlice)
      }
    }
  }

  private static getIntDivisionResultOutputFunction(
    fw: FunctionWrapper
  ): (
    val: IntegerDivisionResult,
    config: Configuration
  ) => {quotient: Int, remainder: Int} {
    return (
      val: IntegerDivisionResult,
      config: Configuration
    ): {quotient: Int, remainder: Int} => {
      // First, check for an infinite result and in that case whether an error should be
      // thrown according to configuration
      if ((Comparison.isPOSITIVE_INFINITY_I(val.quotient) ||
        Comparison.isNEGATIVE_INFINITY_I(val.quotient)) &&
        config.onInfiniteOutput === "throw error") {
        // TODO fill out with infinite result error;
      }

      if ((Comparison.isPOSITIVE_INFINITY_I(val.remainder) ||
        Comparison.isNEGATIVE_INFINITY_I(val.remainder)) &&
        config.onInfiniteOutput === "throw error") {
        // TODO fill out with infinite result error;
      }

      // finally wrap quotient and remainder in Ints
      return {
        quotient: IntUtil.createInt(val.quotient),
        remainder: IntUtil.createInt(val.remainder)
      }
    }
  }


  public static dependencies(): Set<Class> {
    return new Set([
      IntUtil, FloatUtil, IntegerDivisionResult, FloatDivisionResult, Comparison,
      LibError, Configuration, PREC,
    ]);
  }
}


// *** imports come at end to avoid circular dependency ***
import {FunctionWrapper as FunctionWrapperAlias} from "./FunctionWrapper";

// interface/type imports
import {float} from "../../interfacesAndTypes/float";
import {int} from "../../interfacesAndTypes/int";
import {Class} from "../../interfacesAndTypes/Class";
import {TypeDescriptor} from "../../interfacesAndTypes/TypeDescriptor";
import {internalFunctionSpec} from "../../core/Library";
import {ParameterSpec} from "../../interfacesAndTypes/ParameterSpecs/ParameterSpec";
import {PackageFunction, PackageFunctionGen} from "./Input";
import {MethodSpec} from "../API/APISpec";
type FunctionWrapper = FunctionWrapperAlias;

import {P as PAlias} from "../../dataTypes/P";
type P = PAlias;

import {Configuration as ConfigurationAlias} from "../Configuration";
type Configuration = ConfigurationAlias;

// functional imports
import {Int as IntAlias} from "../Int";
type Int = IntAlias;

import {IntUtil as IntUtilAlias} from "../IntUtil";
const IntUtil = IntUtilAlias;

import {Float as FloatAlias} from "../Float";
type Float = FloatAlias;

import {FloatUtil as FloatUtilAlias} from "../FloatUtil";
const FloatUtil = FloatUtilAlias;

import {IntegerDivisionResult as IntegerDivisionResultAlias} from
    "../../dataTypes/IntegerDivisionResult";
const IntegerDivisionResult = IntegerDivisionResultAlias;
type IntegerDivisionResult = IntegerDivisionResultAlias;

import {FloatDivisionResult as FloatDivisionResultAlias} from
    "../../dataTypes/FloatDivisionResult";
const FloatDivisionResult = FloatDivisionResultAlias;
type FloatDivisionResult = FloatDivisionResultAlias;

import {Comparison as ComparisonAlias} from "../../basicFunctions/Comparison";
const Comparison = ComparisonAlias;

import {LibError as LibErrorAlias} from "../../errors/LibError";
const LibError = LibErrorAlias;

const Configuration = ConfigurationAlias;

import {PREC as PRECAlias} from "../../constants/PREC";
const PREC = PRECAlias;
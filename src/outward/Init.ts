"use strict";

import {Export} from "./Export";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


export class Init {
  public static className: string;

  public static init0(): void {
    Init.className = "Init";
  }

  /**
   *  This function takes a list of strings corresponding to the names of library index
   *  file top level exported Objects/Functions and does the following:
   *    - create a list of all needed Classes in the library
   *    - fully initialize those classes and index them in the Library class
   *    - register all needed internal library functions and index them in the Library
   *    class
   *    - create all needed external library functions as Function Wrapper instances and
   *    index them in the library
   */
  public static loadLibrary(indexObjectStrs: Array<string> | null): void {

    // walk apiSpec to find all top level dependencies in API and function info, both
    // in array form
    const walk = Init.walkAPI(indexObjectStrs);

    // register all classes in the library, but make sure to call init0 first, so that
    // className is properly initialized
    let dependenciesToAdd = new Set<Class>([Library, Init, ...walk.classes]);
    const classes = new Set<Class>([]);

    while (dependenciesToAdd.size > 0) {
      let current: Class = [...dependenciesToAdd][0];
      current.init0();
      Library.registerClass(current);
      classes.add(current);
      dependenciesToAdd.delete(current);

      if (typeof current.dependencies !== "undefined") {
        dependenciesToAdd = new Set([
          ...dependenciesToAdd,
          ...([...current.dependencies()].filter(x => !classes.has(x)))
        ]);
      }
    }

    // run init1-6 on all classes if they exist
    for(let c of classes) { if (typeof c.init1 !== "undefined") { c.init1(); } }
    for(let c of classes) { if (typeof c.init2 !== "undefined") { c.init2(); } }
    for(let c of classes) { if (typeof c.init3 !== "undefined") { c.init3(); } }
    for(let c of classes) { if (typeof c.init4 !== "undefined") { c.init4(); } }
    for(let c of classes) { if (typeof c.init5 !== "undefined") { c.init5(); } }
    for(let c of classes) { if (typeof c.init6 !== "undefined") { c.init6(); } }

    // create function wrappers for all function Nodes listed in walk.functionNodes
    // and store them correctly in Library class
    for (let functNode of walk.functionNodes) {
      if (typeof functNode.type === "object") {
        Library.registerIndexFW(new FunctionWrapper(
          functNode.name,
          Library.getInternalFunction(
            functNode.type.containingClass.className,
            functNode.type.functName
          )
        ));
      }

      if (functNode.onLaborer) {
        // TODO: fill this in on implementation of Laborer
      }

      if (Array.isArray(functNode.methods) && typeof functNode.type === "object") {
        for (let methodSpec of functNode.methods) {
          const fw = new FunctionWrapper(
            methodSpec,
            Library.getInternalFunction(
              functNode.type.containingClass.className,
              functNode.type.functName
            )
          );

          if (methodSpec.type === "Float") {
            Library.registerFloatMethodFW(fw);
          } else if (methodSpec.type === "Int") {
            Library.registerIntMethodFW(fw);
          }
        }
      }
    }

    // initiate FloatUtil and IntUtil
    FloatUtil.init();
    IntUtil.init();
  }

  public static indexExportObj(exportObjTopLevelNamesToInclude: Array<string> | null) {
    Init.loadLibrary(exportObjTopLevelNamesToInclude);

    const result: any = {};
    if (exportObjTopLevelNamesToInclude === null) {
      exportObjTopLevelNamesToInclude = APISpec.getAllTopLevelNames();
    }

    for (let name of exportObjTopLevelNamesToInclude) {
      const imp = Init.getTopLevelNodeImplementation(name);
      result[name] = imp;
    }

    return result;
  }

  private static walkAPI(indexObjectKeys: Array<string> | null): {
    classes: Set<Class>,
    functionNodes: Array<Node>
  } {
    const apiSpec = APISpec.get();

    if (indexObjectKeys === null || indexObjectKeys.length === 0) {
      indexObjectKeys = Object.keys(apiSpec);
    }

    const result = {classes: new Set<Class>([]), functionNodes: <Array<Node>>[]};
    const queue: Array<{node: Node, parentName: string}> = [];

    for (let key of indexObjectKeys) {
      queue.push({node: apiSpec[key], parentName: ""});
      Init.walkAPIInternal(queue, result);
    }

    return result;
  }

  private static walkAPIInternal(
    queue: Array<{node: Node, parentName: string}>,
    state: {classes: Set<Class>, functionNodes: Array<Node>}
    ): void {
    const nextInQueue = queue.shift();

    if (typeof nextInQueue !== "undefined") {
      const node = nextInQueue.node;

      if (nextInQueue.parentName !== "") {
        node.name = nextInQueue.parentName + `.${node.name}`;
      }

      if (node.type !== "object") {
        state.classes.add(node.type.containingClass);
        state.functionNodes.push(node);
      }

      if (Array.isArray(node.properties)) {
        for (let prop of node.properties) {
          queue.push({node: prop, parentName: node.name});
        }
      }

      Init.walkAPIInternal(queue, state);
    }
  }

  private static getTopLevelNodeImplementation(
    topLevelNodeName: string
  ): Object | Function {
    const apiSpec = APISpec.get();
    const topLevelNode = apiSpec[topLevelNodeName];
    let result: any;

    if (topLevelNode.type === "object") {
      result = {};
    } else {
      result = Library.getIndexFW(topLevelNode.name).executable();
    }

    Init.setLowerNodes(result, topLevelNode);

    return result;
  }

  private static setLowerNodes(imp: any, node: Node): void {
    if (typeof node.properties === "undefined") { return; }

    for (let childNode of node.properties) {
      const propName = childNode.name;
      childNode.name = `${node.name}.${childNode.name}`;
      let childImp: any;

      if (childNode.type === "object") {
        childImp = {};
      } else {
        childImp = Library.getIndexFW(childNode.name).executable();
      }

      Init.setLowerNodes(childImp, childNode);
      imp[propName] = childImp;
    }
  }


  public static dependencies(): Set<Class> {
    return new Set([
      APISpec, Library, FunctionWrapper, FloatUtil, IntUtil,
    ]);
  }
}


// *** imports come at end to avoid circular dependency ***

// interface/type imports
import {Class} from "../interfacesAndTypes/Class";
import {Node} from "./API/APISpec";

// functional imports
import {APISpec as APISpecAlias} from "./API/APISpec";
const APISpec = APISpecAlias;

import {Library as LibraryAlias} from "../core/Library";
const Library = LibraryAlias;

import {FunctionWrapper as FunctionWrapperAlias}
from "./functionWrapping/FunctionWrapper";
const FunctionWrapper = FunctionWrapperAlias;

import {FloatUtil as FloatUtilAlias} from "./FloatUtil";
const FloatUtil = FloatUtilAlias;

import {IntUtil as IntUtilAlias} from "./IntUtil";
const IntUtil = IntUtilAlias;



// just playing around here

import {C} from "../constants/C";

const index = Init.indexExportObj(null);
const x = FloatUtil.createFloat(C.F_ONE_QUARTER);
const y = IntUtil.createInt(C.I_7);

console.log(index.add.i(x, y).f);
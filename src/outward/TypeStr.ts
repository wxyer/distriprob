"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


export class TypeStr {
  public static className: string;

  private static fltType: string;
  private static intType: string;
  private static booleanType: string;
  private static stringType: string;
  private static numberType: string;
  private static configType: string;
  private static fltEquivalentType: string;
  private static intEquivalentType: string;
  private static numberEquivalentType: string;
  private static defaultSuffix: string;

  private static _paramIndex: {[typeDescriptor: string]: (spec: ParameterSpec) => string};

  public static init0(): void {
    TypeStr.className = "TypeStr";

    TypeStr.fltType = "Float";
    TypeStr.intType = "Int";
    TypeStr.booleanType = "boolean";
    TypeStr.stringType = "string";
    TypeStr.numberType = "number";
    TypeStr.configType = "Config";
    TypeStr.fltEquivalentType =
      `${TypeStr.fltType} | ${TypeStr.intType} | number | string`;
    TypeStr.intEquivalentType = TypeStr.fltEquivalentType;
    TypeStr.numberEquivalentType = TypeStr.fltEquivalentType;
    TypeStr.defaultSuffix = " | null | undefined";

    TypeStr._paramIndex = {
      "boolean": TypeStr.booleanParam,
      "Config": TypeStr.configParam,
      "FloatEquivalent": TypeStr.fltEquivalentParam,
      "Float": TypeStr.fltParam,
      "IntEquivalent": TypeStr.intEquivalentParam,
      "Int": TypeStr.intParam,
      "numberEquivalent": TypeStr.numberEquivalentParam,
      "number": TypeStr.numberParam,
      "string": TypeStr.strParam,
    };
  }

  public static function(
    fw: FunctionWrapper,
    returnTypeDelimiter: string,
  ): string {


    let startIndex = 0;

    while (fw.params.length > startIndex && fw.params[startIndex].instance) {
      startIndex++;
    }

    let result = fw.params.length > startIndex ?
      `(${TypeStr._paramIndex[fw.params[startIndex].type](fw.params[startIndex])}`
      :
      `(`;

    startIndex++;

    for (let i = startIndex; i < fw.params.length; i++) {
      if (!fw.params[i].instance) {
        result += `, ${TypeStr._paramIndex[fw.params[i].type](fw.params[i])}`
      }
    }

    result += `)${returnTypeDelimiter} ${TypeStr.returnTypeStr(fw.returnType)}`;

    return result;
  }


  private static fltEquivalentParam(spec: FloatEquivalentSpec): string {
    return typeof spec.default !== "undefined" ?
      `${spec.name}?: ${TypeStr.fltEquivalentType}${TypeStr.defaultSuffix}`
      :
      `${spec.name}: ${TypeStr.fltEquivalentType}`;
  }

  private static fltParam(spec: FloatSpec): string {
    // if (spec.instance) {
    //   return ``;
    // } else {
    //   return typeof spec.default !== "undefined" ?
    //     `${spec.name}?: ${TypeStr.fltType}${TypeStr.defaultSuffix}`
    //     :
    //     `${spec.name}: ${TypeStr.fltType}`;
    // }

    return typeof spec.default !== "undefined" ?
      `${spec.name}?: ${TypeStr.fltType}${TypeStr.defaultSuffix}`
      :
      `${spec.name}: ${TypeStr.fltType}`;
  }

  private static intEquivalentParam(spec: IntEquivalentSpec): string {
    return typeof spec.default !== "undefined" ?
      `${spec.name}?: ${TypeStr.intEquivalentType}${TypeStr.defaultSuffix}`
      :
      `${spec.name}: ${TypeStr.intEquivalentType}`;
  }

  private static intParam(spec: IntSpec): string {
    if (spec.instance) {
      return ``;
    } else {
      return typeof spec.default !== "undefined" ?
        `${spec.name}?: ${TypeStr.intType}${TypeStr.defaultSuffix}`
        :
        `${spec.name}: ${TypeStr.intType}`;
    }
  }

  private static numberEquivalentParam(spec: NumberEquivalentSpec): string {
    return typeof spec.default !== "undefined" ?
      `${spec.name}?: ${TypeStr.numberEquivalentType}${TypeStr.defaultSuffix}`
      :
      `${spec.name}: ${TypeStr.numberEquivalentType}`;
  }

  private static numberParam(spec: NumberSpec): string {
    return typeof spec.default !== "undefined" ?
      `${spec.name}?: ${TypeStr.numberType}${TypeStr.defaultSuffix}`
      :
      `${spec.name}: ${TypeStr.numberType}`;
  }

  private static booleanParam(spec: BooleanSpec): string {
    if (typeof spec.default !== "undefined") {
      return `${spec.name}?: ${TypeStr.booleanType}${TypeStr.defaultSuffix}`;
    } else {
      return `${spec.name}: ${TypeStr.booleanType}`;
    }
  }

  private static strParam(spec: StringSpec): string {
    const defaultCase = typeof spec.default !== "undefined";

    if (Array.isArray(spec.acceptableValues) && spec.acceptableValues.length > 0) {
      let typeStr = defaultCase ?
        `${spec.name}?: "${spec.acceptableValues[0]}"`
        :
        `${spec.name}: "${spec.acceptableValues[0]}"`;

      for (let i = 1; i < spec.acceptableValues.length; i++) {
        typeStr += ` | "${spec.acceptableValues[i]}"`
      }

      return defaultCase ?
        typeStr + TypeStr.defaultSuffix
        :
        typeStr;
    } else {
      return defaultCase ?
        `${spec.name}?: ${TypeStr.stringType}${TypeStr.defaultSuffix}`
        :
        `${spec.name}: ${TypeStr.stringType}`
    }
  }

  private static configParam(spec: ConfigSpec): string {
    return `${spec.name}?: ${TypeStr.configType}${TypeStr.defaultSuffix}`;
  }

  private static returnTypeStr(returnType: TypeDescriptor): string {
    switch(returnType) {
      case "IntDivResult":
        return `{quotient: Int, remainder: Int}`;
      case "FloatDivResult":
        return `{quotient: Float, remainder: Float}`;
      default:
        return returnType;
    }
  }

}


// *** imports come at end to avoid circular dependency ***

// interface/type imports
import {TypeDescriptor} from "../interfacesAndTypes/TypeDescriptor";
import {ParameterSpec} from "../interfacesAndTypes/ParameterSpecs/ParameterSpec";
import {FloatEquivalentSpec} from
    "../interfacesAndTypes/ParameterSpecs/FloatEquivalentSpec";
import {FloatSpec} from "../interfacesAndTypes/ParameterSpecs/FloatSpec";
import {IntEquivalentSpec} from "../interfacesAndTypes/ParameterSpecs/IntEquivalentSpec";
import {IntSpec} from "../interfacesAndTypes/ParameterSpecs/IntSpec";
import {NumberEquivalentSpec} from
    "../interfacesAndTypes/ParameterSpecs/NumberEquivalentSpec";
import {NumberSpec} from "../interfacesAndTypes/ParameterSpecs/NumberSpec";
import {StringSpec} from "../interfacesAndTypes/ParameterSpecs/StringSpec";
import {BooleanSpec} from "../interfacesAndTypes/ParameterSpecs/BooleanSpec";
import {ConfigSpec} from "../interfacesAndTypes/ParameterSpecs/ConfigSpec";
import {FunctionWrapper as FunctionWrapperAlias} from
    "./functionWrapping/FunctionWrapper";
export type FunctionWrapper = FunctionWrapperAlias;
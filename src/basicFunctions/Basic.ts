"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

import {int} from "../interfaces/int";
import {float} from "../interfaces/float";

import {IntegerDivisionResult as IntegerDivisionResultAlias}
  from "../dataTypes/IntegerDivisionResult";
const IntegerDivisionResult = IntegerDivisionResultAlias;

// functional imports
import {Integer as IntegerAlias} from "../dataTypes/Integer";
const Integer = IntegerAlias;

import {Float as FloatAlias} from "../dataTypes/Float";
const Float = FloatAlias;

import {C as CAlias} from "../constants/C";
const C = CAlias;

import {Sign as SignAlias} from "./Sign";
const Sign = SignAlias;

import {Core as CoreAlias} from "../core/Core";
const Core = CoreAlias;

import {Comparison as ComparisonAlias} from "./Comparison";
const Comparison = ComparisonAlias;

import {Longhand as LonghandAlias} from "../core/Longhand";
const Longhand = LonghandAlias;

import {P as PAlias} from "../dataTypes/P";
const P = PAlias;
export type P = PAlias;


export class Basic {
  // ********************* integer functions ************************************

  public static addII(a: int, b: int): int {
    const aIsFinite = Comparison.isFiniteI(a);
    const bIsFinite = Comparison.isFiniteI(b);

    if (aIsFinite && bIsFinite) {
      if (a.digits.length === 1 && b.digits.length === 1) {
        const sum = (a.neg ? - a.digits[0] : a.digits[0]) +
          (b.neg ? -b.digits[0] : b.digits[0]);
        const absSum = Math.abs(sum);

        if (absSum < C.BASE) {
          return new Integer(sum < 0, Uint32Array.of(absSum))
        } else {
          return Core.numberToIntUnchecked(sum);
        }
      }

      let resultDigits: Uint32Array;
      let negative: boolean;


      if (a.neg === b.neg) {
        negative = a.neg;
        resultDigits = Longhand.addition(a.digits, b.digits);
      } else {
        const sub = Longhand.subtraction(a.digits, b.digits);

        if (sub.aGTEb) {
          negative = a.neg;
        } else if (sub.result.length === 1 && sub.result[0] === 0) {
          return C.I_0;
        } else {
          negative = b.neg;
        }

        resultDigits = sub.result;
      }

      return new Integer(negative, resultDigits);

    } else {
      if (Comparison.isNaN_I(a) || Comparison.isNaN_I(b)) {
        return C.NaN;
      } else if (aIsFinite) {   // b must be +/- infinity
        return b;
      } else if (bIsFinite) {  // a must be +/- infinity
        return a;
      } else { // both a and b are +/- infinity
        const sameSign = Comparison.isNegativeI(a) === Comparison.isNegativeI(b);

        if (sameSign) {
          return a;
        } else {
          return C.NaN;
        }
      }
    }
  }

  public static subtractII(a: int, b: int): int {
    return Basic.addII(a, Sign.negateI(b));
  }

  public static multiplyII(a: int, b: int): int {
    if (Comparison.isFiniteI(a) && Comparison.isFiniteI(b)) {
      if (a.digits.length === 1 && b.digits.length === 1) {
        const absProduct = a.digits[0] * b.digits[0];
        const product = a.neg === b.neg ? absProduct : -1 * absProduct ;

        if (absProduct < C.BASE) {
          return new Integer(product < 0, Uint32Array.of(absProduct))
        } else {
          return Core.numberToIntUnchecked(product);
        }
      } else {
        return Basic.karatsuba(a, b);
      }
    } else if (Comparison.isNaN_I(a) || Comparison.isNaN_I(b)){
      return C.NaN;
    } else if (Comparison.isZeroI(a) || Comparison.isZeroI(b)){
      // one is 0 and the other is +/- infinity
      return C.NaN;
    } else {
      // at least one is +/- infinity and the other is not 0 or NaN
      if (a.neg === b.neg) {
        return C.POSITIVE_INFINITY;
      } else {
        return C.NEGATIVE_INFINITY;
      }
    }
  }

  public static squareI(a: int): int {
    if (Comparison.isFiniteI(a)) {
      if (a.digits.length === 1) {
        const square = a.digits[0] * a.digits[0];

        if (square < C.BASE) {
          return new Integer(false, Uint32Array.of(square))
        } else {
          return Core.numberToIntUnchecked(square);
        }
      } else {
        return Basic.karatsubaSquare(a);
      }
    } else if (Comparison.isNaN_I(a)) {
      return C.NaN;
    } else {
      // a is +/- infinity
      return C.POSITIVE_INFINITY;
    }
  }

  public static divideII(
    a: int,
    b: int,
    type: "euclidean"| "trunc" | "ceil" | "floor" | "round"
  ): {q: int, r: int} {
    if (Comparison.isZeroI(b)) {
      throw new Error("Division by zero error");
    } else if (Comparison.isZeroI(a)) {
      return new IntegerDivisionResult(C.I_0, C.I_0);
    } else if (b.digits.length === 1 && b.digits[0] === 1) { // b === +/-1
      return b.neg ?
        new IntegerDivisionResult(Sign.negateI(a), C.I_0)
        :
        new IntegerDivisionResult(a, C.I_0);
    } else if (Comparison.compareArray(a.digits, b.digits) === 0) { // abs(a) === abs(b)
      return a.neg === b.neg ?
        new IntegerDivisionResult(C.I_1, C.I_0)
        :
        new IntegerDivisionResult(C.I_NEG_1, C.I_0);
    } else {
      const absADivAbsB = Longhand.division(a.digits, b.digits);
      const qIsNegative = a.neg !== b.neg;

      // type = "trunc" results
      let q: int = new Integer(qIsNegative, absADivAbsB.q);
      let r: int = new Integer(a.neg, absADivAbsB.r);

      if (absADivAbsB.r.length === 1 && absADivAbsB.r[0] === 0) { // remainder is zero
        r = C.I_0;
      } else if (type === "euclidean" && a.neg) {
        if (b.neg) {
          q = Basic.addII(q, C.I_1);
          r = Basic.subtractII(r, b);
        } else {
          q = Basic.subtractII(q, C.I_1);
          r = Basic.addII(r, b);
        }
      } else if (type === "ceil" && !qIsNegative) {
        q = Basic.addII(q, C.I_1);
        r = Basic.subtractII(r, b);
      } else if (type === "floor" && qIsNegative) {
        q = Basic.subtractII(q, C.I_1);
        r = Basic.addII(r, b);
      } else if (type === "round") {
        const absBDiv2 = Longhand.divisionBySingleDigit(b.digits, 2);
        const roundCutoff = Longhand.addition(absBDiv2.q, Uint32Array.of(absBDiv2.r));
        if (Comparison.compareArray(b.digits, roundCutoff) >= 0) {
          // in this case q is rounded outward away from 0, no matter its sign
          // which is different from trunc
          if (qIsNegative) {
            q = Basic.subtractII(q, C.I_1);
            r = Basic.addII(r, b);
          } else {
            q = Basic.addII(q, C.I_1);
            r = Basic.subtractII(r, b);
          }
        }
      }

      return new IntegerDivisionResult(q, r);
    }
  }

  // ********************* float functions ************************************

  public static addFF(x: float, y: float, prec: P): float {
    const xIsFinite = Comparison.isFinite(x);
    const yIsFinite = Comparison.isFinite(y);

    if (xIsFinite && yIsFinite) {
      if (Comparison.isZero(x)) {
        return y;
      } else if (Comparison.isZero(y)) {
        return x;
      } else {
        let largerMagVal: float;
        let largerMagValLeastSigDigExp: int;
        let smallerMagVal: float;
        let smallerMagValLeastSigDigExp: int;

        if (Comparison.gte(Sign.absF(x), Sign.absF(y))) {
          largerMagVal = x;
          largerMagValLeastSigDigExp = Basic.leastSigDigPlaceF(x);
          smallerMagVal = y;
          smallerMagValLeastSigDigExp = Basic.leastSigDigPlaceF(y);
        } else {
          largerMagVal = y;
          largerMagValLeastSigDigExp = Basic.leastSigDigPlaceF(y);
          smallerMagVal = x;
          smallerMagValLeastSigDigExp = Basic.leastSigDigPlaceF(x);
        }

        const leastSigDigExp: int = Core.maxI(
          Core.minI(largerMagValLeastSigDigExp, smallerMagValLeastSigDigExp),
          Basic.subtractII(largerMagVal.exp, prec.numDigitsInt)
        );

        if (Comparison.ltI(smallerMagVal.exp, leastSigDigExp)) {
          return largerMagVal;
        }

        const scaledSmallerMagValCoef: int = Basic.scaleFloatCoef(
          smallerMagVal,
          smallerMagValLeastSigDigExp,
          leastSigDigExp
        );
        const scaledLargerMagValCoef: int = Basic.scaleFloatCoef(
          largerMagVal,
          largerMagValLeastSigDigExp,
          leastSigDigExp
        );

        const unroundedCoef = Basic.addII(
          scaledLargerMagValCoef,
          scaledSmallerMagValCoef
        );

        const exp = Basic.addII(
          largerMagVal.exp,
          Core.numberToInt(
            unroundedCoef.digits.length - Math.max(
            scaledSmallerMagValCoef.digits.length,
            scaledLargerMagValCoef.digits.length
            )
          )
        );

        const coef: int = Core.roundOffDigits(unroundedCoef, prec.numDigits);

        return new Float(coef, exp);
      }
    } else {
      if (Comparison.isNaN(x) || Comparison.isNaN(y)) {
        return C.F_NaN;
      } else if (xIsFinite) {   // y must be +/- infinity
        return y;
      } else if (yIsFinite) {  // x must be +/- infinity
        return x;
      } else { // both x and y are +/- infinity
        const xySameSign = Comparison.isNegative(x) === Comparison.isNegative(y);

        if (xySameSign) {
          return x;
        } else {
          return C.F_NaN;
        }
      }
    }
  }

  public static sumF(vals: float[], prec: P): float {
    if (vals.length === 0) { return C.F_0; }

    let sum = vals[0];

    for (let i = 1; i < vals.length; i++) {
      sum = Basic.addFF(sum, vals[i], prec);
    }

    return sum;
  }

  public static subtractFF(x: float, y: float, prec: P): float {
    return Basic.addFF(x, Sign.negateF(y), prec);
  }

  public static multiplyFF(x: float, y: float, prec: P): float {
    if (Comparison.isFinite(x) && Comparison.isFinite(y)) {
      const neg = x.coef.neg !== y.coef.neg;
      const coefDigits = Longhand.multiplicationLengthLimit(
        x.coef.digits,
        y.coef.digits,
        prec.numDigits
      );

      const exp = Basic.addII(Basic.addII(x.exp, y.exp), coefDigits.expAdjustment);

      return new Float(new Integer(neg, coefDigits.result), exp);
    } else if (Comparison.isNaN(x) || Comparison.isNaN(y)) {
      return C.F_NaN;
    } else if (Comparison.isZero(x) || Comparison.isZero(y)) {
      // one is 0 and the other is +/- infinity
      return C.F_NaN
    } else {
      // at least one is +/-infinity and the other is not 0 of NaN
      if (x.coef.neg === y.coef.neg) {
        return C.F_POSITIVE_INFINITY;
      } else {
        return C.F_NEGATIVE_INFINITY;
      }
    }
  }

  public static productF(vals: float[], prec: P): float {
    if (vals.length === 0) { return C.F_0; }

    let product = vals[0];

    for(let i = 1; i < vals.length; i++) {
      product = Basic.multiplyFF(product, vals[i], prec);
    }

    return product;
  }

  public static squareF(x: float, prec: P): float {
    if (Comparison.isFinite(x)) {
      const coefDigits = Longhand.multiplicationLengthLimit(
        x.coef.digits,
        x.coef.digits,
        prec.numDigits
      );
      const exp = Basic.addII(Basic.addII(x.exp, x.exp), coefDigits.expAdjustment);

      return new Float(new Integer(false, coefDigits.result), exp);
    } else if (Comparison.isNaN(x)) {
      return C.F_NaN;
    } else {
      return C.F_POSITIVE_INFINITY;
    }
  }

  public static reciprocalF(x: float, prec: P): float {
    if (Comparison.isNaN(x)) {
      return C.F_NaN;
    } else if (Comparison.isPOSITIVE_INFINITY(x) || Comparison.isNEGATIVE_INFINITY(x)) {
      return C.F_0;
    } else if (Comparison.isZero(x)) {
      return C.F_POSITIVE_INFINITY;
    } else {
      // Newton-Raphson method of finding a reciprocal
      return Basic.newtonInversion(x, prec);
    }
  }

  public static divideFF(x: float, y: float, prec: P): float {
    const xIsFinite = Comparison.isFinite(x);
    const yIsFinite = Comparison.isFinite(y);

    if (xIsFinite && yIsFinite) {
      if (Comparison.isZero(y)) {
        if (Comparison.isPositive(x)) {
          return C.F_POSITIVE_INFINITY;
        } else if (Comparison.isNegative(x)) {
          return C.F_NEGATIVE_INFINITY;
        } else { // 0/0 is undefined
          return C.F_NaN;
        }
      } else if (Comparison.equals(Sign.absF(x), Sign.absF(y))) {
        return x.coef.neg === y.coef.neg ? C.F_1 : C.F_NEG_1;
      } else {
        return Basic.multiplyFF(x, Basic.newtonInversion(y, prec), prec)
      }
    } else if (Comparison.isNaN(x) || Comparison.isNaN(y)) {
      return C.F_NaN;
    } else if (xIsFinite) { // y is +/- infinity
      return C.F_0;
    } else if (yIsFinite) { // x is +/- infinity
      if (x.coef.neg === y.coef.neg) {
        return C.F_POSITIVE_INFINITY;
      } else {
        return C.F_NEGATIVE_INFINITY;
      }
    } else { // both x and y are +/- infinity and infinity/infinity is undefined
      return C.F_NaN;
    }
  }

  // ********************* support functions ************************************

  public static leastSigDigPlaceF(x: float): int {
    return Basic.addII(
      x.exp,
      Core.numberToInt(1 - x.coef.digits.length)
    );
  }

  public static scaleFloatCoef(
    x: float,
    xLeastSigDigExp: int,
    desiredLeastSigDigExp: int
  ): int {
    if (Comparison.gtI(xLeastSigDigExp, desiredLeastSigDigExp)) {
      const zerosToAdd = Core.intToNumber(Basic.subtractII(
        xLeastSigDigExp,
        desiredLeastSigDigExp
      ));

      return new Integer(
        x.coef.neg,
        Core.scaleArrayByBase(x.coef.digits, zerosToAdd)
      );
    } else {
      const digitsToKeep: number = 1 + Core.intToNumber(Basic.subtractII(
        x.exp,
        desiredLeastSigDigExp
      ));

      return Core.roundOffDigits(
        x.coef,
        digitsToKeep
      );
    }
  }

  public static karatsuba(a: int, b: int): int {
    if (Comparison.isZeroI(a) || Comparison.isZeroI(b)) {
      return C.I_0;
    } else if (a.digits.length === 1 && a.digits[0] === 1) { // a === +/-1
      return a.neg ? Sign.negateI(b) : b;
    } else if (b.digits.length === 1 && b.digits[0] === 1) { // b === +/-1
      return b.neg ? Sign.negateI(a) : a;
    } else if (a.digits.length <= 200 || b.digits.length <= 200
      || a.digits.length/b.digits.length < 0.15
      || b.digits.length/a.digits.length < 0.15) {
      return new Integer(
        a.neg !== b.neg,
        Longhand.multiplication(a.digits, b.digits)
      );
    } else {
      const n = Math.max(a.digits.length, b.digits.length);
      const m = Math.ceil(n/2);
      const aSplit = Core.splitInt(a, m);
      const bSplit = Core.splitInt(b, m);

      const z2 = Basic.multiplyII(aSplit.hi, bSplit.hi);
      const z0 = Basic.multiplyII(aSplit.lo, bSplit.lo);
      const z1 = Basic.addII(
        Basic.addII(
          Basic.multiplyII(
            Basic.subtractII(aSplit.lo, aSplit.hi),
            Basic.subtractII(bSplit.hi, bSplit.lo)
          ),
          z2
        ),
        z0
      );

      const summand2 = Core.scaleIntByBase(z2, 2*m);
      const summand1 = Core.scaleIntByBase(z1, m);

      return Basic.addII(Basic.addII(summand2, summand1), z0);
    }
  }

  public static karatsubaSquare(a: int): int {
    if (Comparison.isZeroI(a)) {
      return C.I_0;
    } else if (a.digits.length === 1 && a.digits[0] === 1) { // a === +/-1
      return Sign.absI(a);
    } else if (a.digits.length <= 200) {
      return new Integer(false, Longhand.square(a.digits));
    } else {
      const n = a.digits.length;
      const m = Math.ceil(n/2);
      const aSplit = Core.splitInt(a, m);

      const z2 = Basic.squareI(aSplit.hi);
      const z0 = Basic.squareI(aSplit.lo);
      const z1 = Basic.addII(
        Basic.addII(
          Sign.negateI(Basic.squareI(Basic.subtractII(aSplit.lo, aSplit.hi))),
          z2
        ),
        z0
      );

      const summand2 = Core.scaleIntByBase(z2, 2*m);
      const summand1 = Core.scaleIntByBase(z1, m);

      return Basic.addII(Basic.addII(summand2, summand1), z0);
    }
  }

  /**
   * This function takes a finite float x and decomposes its absolute value into a
   * finite integer number c and a finite int e such that:
   *
   *      c =(approx)= |x| * (BASE^(-e))  i.e.  |x| =(approx)= c * (BASE^e)
   *
   * @param {float} x - a finite float
   * @returns {{c: number; e: int}}
   */
  public static sciNoteBASEApprox(x: float): {c: number, e: int} {
    const maxIter = Math.min(3, x.coef.digits.length);
    const maxIterMinus1 = maxIter - 1;
    let c = 0;

    for (let i = 0; i < maxIter; i++) {
      c += x.coef.digits[i];
      if (i !== maxIterMinus1) {
        c *= C.BASE;
      }
    }

    return {c: c, e: Basic.subtractII(x.exp, Core.numberToInt(maxIterMinus1))};
  }

  public static newtonInversion(x: float, prec: P): float {
    const sciNote = Basic.sciNoteBASEApprox(x);
    const zInv = 1/sciNote.c;
    const zInvFloat = Core.numberToFloatUnchecked(zInv);

    // here is our initial estimate of 1/x
    let yi = new Float(
      new Integer(x.coef.neg, zInvFloat.coef.digits),
      Basic.subtractII(zInvFloat.exp, sciNote.e)
    );

    // now refine it with Newton-Raphson method using f(y) = (1/y) - D, thus
    // f'(y) = -y^(-2) so the iterative step is:
    // y_i+1 = 2 * y_i - x * y_i^2
    const steps = prec.quadraticConvergenceSteps;

    for (let i = 0; i < steps; i++) {
      const xTimesYi = Basic.multiplyFF(x, yi, prec);
      const oneMinusXYi = Basic.subtractFF(C.F_1, xTimesYi, prec);

      if (Comparison.lt(Sign.absF(oneMinusXYi), prec.epsilon) ) {
        break;
      }

      const xTimesYiSquared = Basic.multiplyFF(xTimesYi, yi, prec);
      const twoTimesYi = Basic.multiplyFF(C.F_2, yi, prec);

      yi = Basic.subtractFF(twoTimesYi, xTimesYiSquared, prec);
    }

    return yi;
  }
}


"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

import {int} from "../interfaces/int";

import {Integer} from "../dataTypes/Integer";

import {C as CAlias} from "../constants/C";
const C = CAlias;


export class Bitwise {
  private static SINGLE_BITMASKS: Uint32Array;
  private static VALID_BITS_MASK: number;

  private static setup(): void {
    const bitmasks: number[] = [1];
    for (let i = 1; i < C.POWER_OF_TWO_FOR_BASE; i++) { bitmasks.push(1<<i); }
    Bitwise.SINGLE_BITMASKS = Uint32Array.from(bitmasks);

    let validBits = 0;
    for (let i = 0; i < C.POWER_OF_TWO_FOR_BASE; i++) {validBits |= bitmasks[i]; }
    Bitwise.VALID_BITS_MASK = validBits;
  }

  public static andI(a: int, b: int): int {
    const shorterLength = Math.min(a.digits.length, b.digits.length);

    let resultDigits: Uint32Array = new Uint32Array(shorterLength);

    for (let i = 1; i <= shorterLength; i++) {
      resultDigits[shorterLength - i] =
        a.digits[a.digits.length - i]
        &
        b.digits[b.digits.length - 1];
    }

    return Bitwise.eliminateLeadingZeros(resultDigits);
  }

  public static orI(a: int, b: int): int {
    let longer: Uint32Array;
    let longerLength: number;
    let shorter: Uint32Array;
    let shorterLength: number;

    if (a.digits.length > b.digits.length) {
      longer = a.digits;
      longerLength = a.digits.length;
      shorter = b.digits;
      shorterLength = b.digits.length;
    } else {
      longer = b.digits;
      longerLength = b.digits.length;
      shorter = a.digits;
      shorterLength = a.digits.length;
    }

    const resultDigits = new Uint32Array(longerLength);
    let longerLengthMinusI: number;
    let i: number;

    for(i = 1; i <= shorterLength; i++) {
      longerLengthMinusI = longerLength - i;
      resultDigits[longerLengthMinusI] =
        longer[longerLengthMinusI]
        |
        shorter[shorterLength - i];
    }

    while(i <= longerLength) {
      longerLengthMinusI = longerLength - i;
      resultDigits[longerLengthMinusI] = longer[longerLengthMinusI];
      i++;
    }

    return new Integer(false, resultDigits);
  }

  public static xorI(a: int, b: int): int {
    let longer: Uint32Array;
    let longerLength: number;
    let shorter: Uint32Array;
    let shorterLength: number;

    if (a.digits.length > b.digits.length) {
      longer = a.digits;
      longerLength = a.digits.length;
      shorter = b.digits;
      shorterLength = b.digits.length;
    } else {
      longer = b.digits;
      longerLength = b.digits.length;
      shorter = a.digits;
      shorterLength = a.digits.length;
    }

    const resultDigits = new Uint32Array(longerLength);
    let longerLengthMinusI: number;
    let i: number;

    for(i = 1; i <= shorterLength; i++) {
      longerLengthMinusI = longerLength - i;
      resultDigits[longerLengthMinusI] =
        longer[longerLengthMinusI]
        ^
        shorter[shorterLength - i];
    }

    while(i <= longerLength) {
      longerLengthMinusI = longerLength - i;
      resultDigits[longerLengthMinusI] = longer[longerLengthMinusI];
      i++;
    }

    return Bitwise.eliminateLeadingZeros(resultDigits);
  }

  public static leftShiftI(a: int, places: number): int {
    if (typeof Bitwise.SINGLE_BITMASKS === "undefined") { Bitwise.setup(); }
    if (places === 0 || (a.digits.length === 1 && a.digits[0] === 0)) { return a; }
    if (places < 0) { return Bitwise.rightShiftI(a, -places); }

    const fullCellPlaces = Math.trunc(places/C.POWER_OF_TWO_FOR_BASE);
    const remainderPlaces = places % C.POWER_OF_TWO_FOR_BASE;
    // console.log("remainder places:", remainderPlaces);
    const topToBottomShift = C.POWER_OF_TWO_FOR_BASE - remainderPlaces;
    const topMask = Bitwise.topMask(remainderPlaces);
    // console.log("topMask:", topMask.toString(2));
    let topBits = a.digits[0] & topMask;
    // console.log("topBits:", topBits.toString(2));
    // console.log("topToBottomShift:", topToBottomShift);
    // console.log("topBits >>> topToBottomShift:", (topBits >>> topToBottomShift).toString(2));
    let nonZeroTopBits = topBits !== 0;
    const adjustment = nonZeroTopBits ? 1 : 0;
    const resultDigits = new Uint32Array(
      a.digits.length + fullCellPlaces + adjustment
    );
    if (nonZeroTopBits){ resultDigits[0] ^= topBits >>> topToBottomShift; }
    let resultIndex = adjustment;
    let aIndex = 0;

    while(true) {
      resultDigits[resultIndex] =
        (a.digits[aIndex] << remainderPlaces)
        &
        Bitwise.VALID_BITS_MASK;
      aIndex++;

      if (aIndex < a.digits.length) {
        topBits = a.digits[aIndex] & topMask;
        // console.log("topBits:", topBits.toString(2));
        resultDigits[resultIndex] ^= topBits >>> topToBottomShift;
        resultIndex++;
      } else {
        break;
      }
    }

    return new Integer(a.neg, resultDigits);
  }

  public static rightShiftI(a: int, places: number): int {
    if (typeof Bitwise.SINGLE_BITMASKS === "undefined") { Bitwise.setup(); }
    if (places === 0 || (a.digits.length === 1 && a.digits[0] === 0)) { return a; }
    if (places < 0) { return Bitwise.leftShiftI(a, -places); }

    const fullCellPlaces = Math.trunc(places/C.POWER_OF_TWO_FOR_BASE);
    const remainderPlaces = places % C.POWER_OF_TWO_FOR_BASE;
    const bottomToTopShift = C.POWER_OF_TWO_FOR_BASE - remainderPlaces;
    const bottomMask = Bitwise.bottomMask(remainderPlaces);
    let topBits = a.digits[0] >>> remainderPlaces;
    // console.log("topBits:", topBits);
    const resultDigitsLength = a.digits.length - fullCellPlaces - (topBits !== 0 ? 0 : 1);

    if (resultDigitsLength === 0) { return C.I_0; }

    const resultDigits = new Uint32Array(resultDigitsLength);
    // console.log("resultDigits.length:", resultDigits.length);
    let resultIndex: number;
    if (topBits !== 0) {
      resultDigits[0] ^= topBits;
      resultIndex = 1;
    } else {
      resultIndex = 0;
    }
    let aIndex = 0;
    let bottomBits: number;

    while(resultIndex < resultDigits.length){
      bottomBits = a.digits[aIndex] & bottomMask;
      resultDigits[resultIndex] = bottomBits << bottomToTopShift;
      aIndex++;
      resultDigits[resultIndex] ^= a.digits[aIndex] >>> remainderPlaces;
      resultIndex++;
    }


    return new Integer(a.neg, resultDigits);
  }

  public static lengthI(a: int): number {
    if (typeof Bitwise.SINGLE_BITMASKS === "undefined") { Bitwise.setup(); }
    const fullPositionBits = (a.digits.length - 1) * C.POWER_OF_TWO_FOR_BASE;

    let i = C.POWER_OF_TWO_FOR_BASE - 1;
    while(i >= 0 && (a.digits[0] & Bitwise.SINGLE_BITMASKS[i]) === 0) { i--; }
    const partialPositionBits = i + 1;

    return fullPositionBits + partialPositionBits;
  }

  private static eliminateLeadingZeros(digits: Uint32Array): int {
    // check for and eliminate leading zeros;
    let i = 0;
    const digitsLengthMinus1 = digits.length - 1;
    while(i < digitsLengthMinus1 && digits[i] === 0) { i++; }

    if (i > 0) {
      return new Integer(false, digits.slice(i))
    } else {
      return new Integer(false, digits);
    }
  }

  private static topMask(places: number): number {
    const lim = C.POWER_OF_TWO_FOR_BASE - places;
    let result = 0;

    for(let i = C.POWER_OF_TWO_FOR_BASE - 1; i >= lim; i--) {
      result ^= Bitwise.SINGLE_BITMASKS[i];
    }

    return result;
  }

  private static bottomMask(places: number): number {
    let result = 0;

    for(let i = 0; i < places; i++) {
      result ^= Bitwise.SINGLE_BITMASKS[i];
    }

    return result;
  }
}



"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


export class Comparison {
  public static className: string;

  public static init0(): void {
    Comparison.className = "Comparison";
  }

  // integer functions
  public static compareI(a: int, b: int): number {
    if (!Comparison.isFiniteI(a) || !Comparison.isFiniteI(b)) {
      if (Comparison.isNaN_I(a) || Comparison.isNaN_I(b)) {
        throw new NaNError(
          Comparison.className,
          "compareI",
          Comparison.isNaN_I(a) ? "a" : "b"
        );
      } else if (Comparison.isPOSITIVE_INFINITY_I(a)) {
        return Comparison.isPOSITIVE_INFINITY_I(b) ? 0 : 1;
      } else if (Comparison.isNEGATIVE_INFINITY_I(a)) {
        return Comparison.isNEGATIVE_INFINITY_I(b) ? 0 : -1;
      } else { // a is finite and b is +/- infinity
        return Comparison.isPOSITIVE_INFINITY_I(b) ? -1 : 1;
      }
    } else if (a.neg !== b.neg) {
      return a.neg ? -1 : 1;
    }

    return a.neg ?
      -Comparison.compareArray(a.digits, b.digits)
      :
      Comparison.compareArray(a.digits, b.digits);
  }

  public static isZeroI(a: int): boolean {
    return a.digits.length === 1 && a.digits[0] === 0;
  }

  public static isOneI(a: int): boolean {
    return !a.neg && a.digits.length === 1 && a.digits[0] === 1;
  }

  public static isNegativeOneI(a: int): boolean {
    return a.neg && a.digits.length === 1 && a.digits[0] === 1;
  }

  public static isPositiveI(a: int): boolean {
    return !a.neg &&
      (a.type === intType.infinite ||  (a.digits.length > 1 || a.digits[0] > 0));
  }

  public static isNegativeI(a: int): boolean {
    return a.neg;
  }

  public static equalsI(a: int, b: int): boolean {
    return Comparison.compareI(a, b) === 0;
  }

  public static gtOneI(a: int): boolean {
    return !a.neg && (a.digits.length > 1 || a.digits[0] > 1);
  }

  public static gteOneI(a: int): boolean {
    return !a.neg && (a.digits.length > 1 || a.digits[0] > 0);
  }

  public static ltOneI(a: int): boolean {
    return a.neg || (a.digits.length === 1 && a.digits[0] === 0);
  }

  public static lteOneI(a: int): boolean {
    return a.neg || (a.digits.length === 1 && a.digits[0] <= 1)
  }

  public static gtI(a: int, b: int): boolean {
    return Comparison.compareI(a, b) > 0;
  }

  public static gteI(a: int, b: int): boolean {
    return Comparison.compareI(a, b) >= 0;
  }

  public static ltI(a: int, b: int): boolean {
    return Comparison.compareI(a, b) < 0;
  }

  public static lteI(a: int, b: int): boolean {
    return Comparison.compareI(a, b) <= 0;
  }

  public static isFiniteI(a: int): boolean {
    return a.type === intType.finite;
  }

  public static isNaN_I(a: int): boolean {
    return Number.isNaN(a.digits[0]);
  }

  public static isPOSITIVE_INFINITY_I(a: int): boolean {
    return !a.neg && a.type === intType.infinite;
  }

  public static isNEGATIVE_INFINITY_I(a: int): boolean {
    return a.neg && a.type === intType.infinite;
  }

  // **************** float functions *******************************************

  public static compare(x: float, y: float): number {
    if (!Comparison.isFinite(x) || !Comparison.isFinite(y)) {
      if (Comparison.isNaN(x) || Comparison.isNaN(y)) {
        throw new NaNError(
          Comparison.className,
          "compare",
          Comparison.isNaN(x) ? "x" : "y"
        );
      } else if (Comparison.isPOSITIVE_INFINITY(x)) {
        return Comparison.isPOSITIVE_INFINITY(y) ? 0 : 1;
      } else if (Comparison.isNEGATIVE_INFINITY(x)) {
        return Comparison.isNEGATIVE_INFINITY(y) ? 0 : -1;
      } else { // x is finite and y is +/- infinity
        return Comparison.isPOSITIVE_INFINITY(y) ? -1 : 1;
      }
    } else {
      if (x.coef.neg !== y.coef.neg) {
        return x.coef.neg ? -1 : 1;
      } else {
        if (Comparison.isZero(x)) {
          return Comparison.isZero(y) ? 0 : -1;
        } else if (Comparison.isZero(y)) {
          return 1;
        }

        const comp = Comparison.compareI(x.exp, y.exp);
        const bothAreNegative = x.coef.neg;

        if (comp > 0) {          // x.exp > y.exp
          return bothAreNegative ? -1 : 1;
        } else if (comp < 0) {   // x.exp < y.exp
          return bothAreNegative ? 1 : -1;
        } else {                 // x.exp === y.exp
          const xCoefDigits = x.coef.digits;
          const yCoefDigits = y.coef.digits;
          let sameLength: boolean;
          let minLength: number;
          let xHasMaxLengthCoef: boolean;

          if (xCoefDigits.length > yCoefDigits.length){
            sameLength = false;
            minLength = yCoefDigits.length;
            xHasMaxLengthCoef = true;
          } else if (xCoefDigits.length < yCoefDigits.length) {
            sameLength = false;
            minLength = xCoefDigits.length;
            xHasMaxLengthCoef = false;
          } else {
            sameLength = true;
            minLength = xCoefDigits.length;
            xHasMaxLengthCoef = false;
          }

          for(let i = 0; i < minLength; i++) {
            if (xCoefDigits[i] > yCoefDigits[i]) {
              return bothAreNegative ? -1 : 1;
            } else if (xCoefDigits[i] < yCoefDigits[i]) {
              return bothAreNegative ? 1 : -1;
            }
          }

          if (sameLength) {
            return 0;
          } else if (xHasMaxLengthCoef) {
            return bothAreNegative ? -1 : 1;
          } else {
            return bothAreNegative ? 1 : -1
          }
        }
      }
    }
  }

  public static isZero(x: float): boolean {
    return x.coef.digits.length === 1 && x.coef.digits[0] === 0
  }

  public static isOne(x: float): boolean {
    return !x.coef.neg && x.coef.digits.length === 1 && x.coef.digits[0] === 1
      && x.exp.digits.length === 1 && x.exp.digits[0] === 0;
  }

  public static isNegativeOne(x: float): boolean {
    return x.coef.neg && x.coef.digits.length === 1 && x.coef.digits[0] === 1
      && x.exp.digits.length === 1 && x.exp.digits[0] === 0;
  }

  public static isPositive(x: float): boolean {
    return !x.coef.neg &&
      (x.coef.type === intType.infinite
        || (x.coef.digits.length > 1 || x.coef.digits[0] !== 0));
  }

  public static isNegative(x: float): boolean {
    return x.coef.neg;
  }

  public static equals(x: float, y: float): boolean {
    return Comparison.compare(x, y) === 0;
  }

  public static gtOne(x: float): boolean {
    return Comparison.compare(x, C.F_1) > 0;
  }

  public static gteOne(x: float): boolean {
    return Comparison.compare(x, C.F_1) >= 0;
  }

  public static ltOne(x: float): boolean {
    return Comparison.compare(x, C.F_1) < 0;
  }

  public static lteOne(x: float): boolean {
    return Comparison.compare(x, C.F_1) <= 0;
  }

  public static gt(x: float, y: float): boolean {
    return Comparison.compare(x, y) > 0;
  }

  public static gte(x: float, y: float): boolean {
    return Comparison.compare(x, y) >= 0;
  }

  public static lt(x: float, y: float): boolean {
    return Comparison.compare(x, y) < 0;
  }

  public static lte(x: float, y: float): boolean {
    return Comparison.compare(x, y) <= 0;
  }

  public static isFinite(x: float): boolean {
    return x.coef.type === intType.finite;
  }

  public static isNaN(x: float): boolean {
    return x.coef.type === intType.NaN;
  }

  public static isPOSITIVE_INFINITY(x: float): boolean {
    return x.coef.type === intType.infinite && !x.coef.neg;
  }

  public static isNEGATIVE_INFINITY(x: float): boolean {
    return x.coef.type === intType.infinite && x.coef.neg;
  }

  //********************** support functions ********************************************

  public static compareArray(a: Uint32Array, b: Uint32Array): number {
    if (a.length > b.length) {
      return 1;
    } else if (a.length < b.length) {
      return -1;
    } else { // a.length === b.length
      for (let i = 0; i < a.length; i++) {
        if (a[i] > b[i]) {
          return 1;
        } else if (a[i] < b[i]) {
          return -1;
        }
      }

      return 0;
    }
  }


  // class dependencies
  public static dependencies(): Set<Class> {
    return new Set([
      C, NaNError
    ]);
  }
}


// *** imports come at end to avoid circular dependency ***

// interface/type imports
import {int, intType} from "../interfacesAndTypes/int";
import {float} from "../interfacesAndTypes/float";
import {Class} from "../interfacesAndTypes/Class";


// functional imports
import {C as CAlias} from "../constants/C";
const C = CAlias;

import {NaNError as NaNErrorAlias} from "../errors/NaNError";
const NaNError = NaNErrorAlias;


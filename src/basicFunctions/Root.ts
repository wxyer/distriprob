"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

// interface imports
import {int} from "../interfaces/int";
import {float} from "../interfaces/float";


// functional imports
import {C as CAlias} from "../constants/C";
const C = CAlias;

import {Sign as SignAlias} from "./Sign";
const Sign = SignAlias;

import {Comparison as ComparisonAlias} from "./Comparison";
const Comparison = ComparisonAlias;

import {P as PAlias} from "../dataTypes/P";
const P = PAlias;
export type P = PAlias;

import {Core as CoreAlias} from "../core/Core";
const Core = CoreAlias;

import {Pow as PowAlias} from "./Pow";
const Pow = PowAlias;

import {Basic as BasicAlias} from "./Basic";
const Basic = BasicAlias;

import {RATIO as RATIOAlias} from "../constants/RATIO";
const RATIO = RATIOAlias;


export class Root {
  private static _table: {[n: number]: {[x: number]: {value: float, numDigits: number}}};

  /**
   * @param {float} x - a non-negative float
   * @param {P} prec
   * @returns {float}
   */
  public static squareF(x: float, prec: P): float {
    if (Comparison.isZero(x)) {
      return C.F_0;
    } else if (Comparison.isPOSITIVE_INFINITY(x)) {
      return C.F_POSITIVE_INFINITY;
    } else {

      return Root.newtonsMethodSqrt(x, prec)
    }
  }

  public static fn(x: float, n: number, prec: P) {
    if (Comparison.isZero(x)) {
      return n < 0 ? C.F_POSITIVE_INFINITY : C.F_0;
    } else {
      const negativeX = Comparison.isNegative(x);
      if (negativeX) {
        if (n % 2 === 0) {
          throw new Error(
            `Cannot take even root of an negative number, n = ${n}, x = ${x}`
          );
        }
        if (Comparison.isNEGATIVE_INFINITY(x)) {
          return C.F_NEGATIVE_INFINITY;
        }
      }

      if (Comparison.isPOSITIVE_INFINITY(x)) {
        return C.F_POSITIVE_INFINITY;
      }

      const absX = Sign.absF(x);
      const absResult = Root.newtonsMethodGeneral(absX, n, prec);

      return negativeX ? Sign.negateF(absResult) : absResult;
    }
  }

  public static valueFromTable(x: number, n: number, prec: P): float {
    if (typeof Root._table === "undefined") { Root._table = {}; }

    const negative = x < 0;

    if (x < 0) { x = Math.abs(x); }

    if (typeof Root._table[n] === "undefined") { Root._table[n] = {}; }

    let entry = Root._table[n][x];

    if (typeof entry === "undefined") {
      const xFloat = Core.numberToFloatUnchecked(x);
      const value = n === 2 ? Root.squareF(xFloat, prec) : Root.fn(xFloat, n, prec);
      entry = {
        value: value,
        numDigits: prec.numDigits
      };
      Root._table[n][x] = entry;
    } else if (entry.numDigits < prec.numDigits) {
      const xFloat = Core.numberToFloatUnchecked(x);
      entry.value = n === 2 ? Root.squareF(xFloat, prec) : Root.fn(xFloat, n, prec);
      entry.numDigits = prec.numDigits;
    }

    return negative ? Sign.negateF(entry.value) : entry.value;
  }

  public static approx(x: float, n: number): float {
    //Using Number functions can't gives us much better accuracy than 3 BASE digits
    const approxPrec = P.createPFromNumDigits(3);
    const nInt = Core.numberToIntUnchecked(n);

    const sciNote = Basic.sciNoteBASEApprox(x);
    const coefNum = sciNote.c;

    const coefRootApprox = Core.numberToFloatUnchecked(Math.pow(coefNum, 1/n));

    const expDivN = Basic.divideII(
      Basic.multiplyII(sciNote.e, C.POWER_OF_TWO_FOR_BASE_INT),
      nInt,
      "round"
    );
    const twoToExNQuotient: float = Pow.fi(C.F_2, expDivN.q, approxPrec);
    const remainderNum = Core.intToNumber(expDivN.r);

    let nthRootOf2toEx: float;

    if (Comparison.isZeroI(expDivN.r)) {
      nthRootOf2toEx = twoToExNQuotient;
    } else {
      const twoToRemainderDivN = Core.numberToFloat(Math.pow(2, remainderNum/n));

      nthRootOf2toEx = Basic.multiplyFF(twoToExNQuotient, twoToRemainderDivN, approxPrec);
    }

    return Basic.multiplyFF(coefRootApprox, nthRootOf2toEx, approxPrec);
  }


  /**
   * Newton method based on f(xi) = (xi^-2) - x, which has roots at +/-(x^-(1/2))
   * @param {float} x - a positive float
   * @param {P} prec
   * @returns {float}
   */
  public static newtonsMethodSqrt(x: float, prec: P): float {
    const steps = prec.quadraticConvergenceSteps;
    const xNum = Core.floatToNumber(x);
    const guess = Number.isFinite(xNum) && xNum !== 0 ?
      Core.numberToFloat(Math.pow(xNum, -1/2))
      :
      Root.approx(x, -2);
    let xi = guess;
    let oneMinusXTimesXiSquared: float;

    for (let i = 0; i < steps; i++) {
      oneMinusXTimesXiSquared = Basic.subtractFF(
        C.F_1,
        Basic.multiplyFF(x, Basic.squareF(xi, prec), prec),
        prec
      );

      if (Comparison.isZero(oneMinusXTimesXiSquared)) { break; }

      xi = Basic.addFF(
        xi,
        Basic.productF([C.F_ONE_HALF, xi, oneMinusXTimesXiSquared], prec),
        prec
      );
    }

    return Basic.multiplyFF(x, xi, prec);
  }

  /**
   * Newton method based on f(xi) = (xi^-n) - x, which has roots at +/-(x^-(1/n))
   * @param {float} x - a positive float
   * @param {number} n
   * @param {P} prec
   * @returns {float}
   */
  public static newtonsMethodGeneral(x: float, n: number, prec: P): float {
    const steps = prec.quadraticConvergenceSteps;
    const xNum = Core.floatToNumber(x);
    const nInt = Core.numberToInt(n);
    const recipN = n < 100 ?
      RATIO.value(1, n, prec)
      :
      Basic.reciprocalF(Core.numberToFloatUnchecked(n), prec);
    const guess = Number.isFinite(xNum) && xNum !== 0 ?
      Core.numberToFloat(Math.pow(xNum, -1/n))
      :
      Root.approx(x, -n);

    let xi: float = guess;
    let oneMinusXTimesXiToN: float;

    for (let i = 0; i < steps; i++) {
      oneMinusXTimesXiToN = Basic.subtractFF(
        C.F_1,
        Basic.multiplyFF(x, Pow.fi(xi, nInt, prec), prec),
        prec
      );

      if (Comparison.isZero(oneMinusXTimesXiToN)) { break; }

      xi = Basic.addFF(
        xi,
        Basic.productF([recipN, xi, oneMinusXTimesXiToN], prec),
        prec
      );
    }

    return Basic.reciprocalF(xi, prec);
  }
}
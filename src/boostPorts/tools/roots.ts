"use strict";

/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2018 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


export class Roots {
  public static className: string;

  public static init0(): void {
    Roots.className = "Roots";
  }

  private f: (x: float) => { f0: float, f1: float, f2?: float };
  private f0: float;
  private lastF0: float;
  private f1: float;
  private f2: float;
  private delta: float;
  private result: float;
  private guess: float;
  private min: float;
  private max: float;
  private p: P;

  constructor(
    f: (x: float) => { f0: float, f1: float, f2?: float },
    guess: float,
    min: float,
    max: float,
    p: P
  ) {
    this.f = f;
    this.lastF0 = C.F_0;
    this.f0 = C.F_0;
    this.delta = C.F_POSITIVE_INFINITY;
    this.result = guess;
    this.guess = guess;
    this.min = min;
    this.max = max;
    this.p = p;
  }

  private handleZeroDerivative(): void {
    if (Comparison.isZero(this.lastF0)) {
      // this must be the first iteration, pretend that we had a
      // previous one at either min or max:
      if (Comparison.equals(this.result, this.min)) {
        this.guess = this.max;
      } else {
        this.guess = this.min;
      }
      this.lastF0 = this.f(this.guess).f0;
      this.delta = Basic.subtractFF(this.guess, this.result, this.p);
    }

    if (Sign.f(this.lastF0) * Sign.f(this.f0) < 0) {
      // we've crossed over so move in opposite direction to last step:
      if (Comparison.isNegative(this.delta)) {
        this.delta = Basic.multiplyFF(
          Basic.subtractFF(this.result, this.min, this.p),
          C.F_ONE_HALF,
          this.p
        );
      } else {
        this.delta = Basic.multiplyFF(
          Basic.subtractFF(this.result, this.max, this.p),
          C.F_ONE_HALF,
          this.p
        );
      }
    } else {
      // move in same direction as last step:
      if (Comparison.isNegative(this.delta)) {
        this.delta = Basic.multiplyFF(
          Basic.subtractFF(this.result, this.max, this.p),
          C.F_ONE_HALF,
          this.p
        );
      } else {
        this.delta = Basic.multiplyFF(
          Basic.subtractFF(this.result, this.min, this.p),
          C.F_ONE_HALF,
          this.p
        );
      }
    }
  }

  private newtonRaphsonIterate(
    maxIter: number
  ): { result: float, iterations: number } {
    let delta1 = this.delta;
    let delta2 = this.delta;
    let count = maxIter;
    let fResult: { f0: float, f1: float };

    do {
      this.lastF0 = this.f0;
      delta2 = delta1;
      delta1 = this.delta;
      fResult = this.f(this.result);
      this.f0 = fResult.f0;
      this.f1 = fResult.f1;

      count--;

      if (Comparison.isZero(this.f0)) {
        break;
      }
      if (Comparison.isZero(this.f1)) {
        this.handleZeroDerivative();
      } else {
        this.delta = Basic.divideFF(this.f0, this.f1, this.p);
      }

      if (Comparison.gt(
        Sign.absF(Basic.multiplyFF(this.delta, C.F_2, this.p)),
        Sign.absF(delta2)
      )) {
        // last two steps haven't converged, try bisection:
        this.delta = Comparison.isPositive(this.delta) ?
          Basic.multiplyFF(
            Basic.subtractFF(this.result, this.min, this.p),
            C.F_ONE_HALF,
            this.p
          )
          :
          Basic.multiplyFF(
            Basic.subtractFF(this.result, this.max, this.p),
            C.F_ONE_HALF,
            this.p
          );
      }

      this.guess = this.result;
      this.result = Basic.subtractFF(this.result, this.delta, this.p);

      if (Comparison.lte(this.result, this.min)) {
        this.delta = Basic.multiplyFF(
          Basic.subtractFF(this.guess, this.min, this.p),
          C.F_ONE_HALF,
          this.p
        );
        this.result = Basic.subtractFF(this.guess, this.delta, this.p);

        if (Comparison.equals(this.result, this.min)
          || Comparison.equals(this.result, this.max)) {
          break;
        }
      } else if (Comparison.gte(this.result, this.max)) {
        this.delta = Basic.multiplyFF(
          Basic.subtractFF(this.guess, this.max, this.p),
          C.F_ONE_HALF,
          this.p
        );
        this.result = Basic.subtractFF(this.guess, this.delta, this.p);

        if (Comparison.equals(this.result, this.min)
          || Comparison.equals(this.result, this.max)) {
          break;
        }
      }
      // update brackets:
      if (Comparison.isPositive(this.delta)) {
        this.max = this.guess;
      } else {
        this.min = this.guess;
      }
    } while (count && Comparison.lt(
        Sign.absF(Basic.multiplyFF(this.result, this.p.epsilon, this.p)),
        Sign.absF(this.delta)
      ));

    maxIter -= count;

    return {result: this.result, iterations: maxIter};
  }

  private secondOrderRootFinder(
    maxIter: number,
    step: (x: float, f0: float, f1: float, f2: float) => float
  ): { result: float, iterations: number } {
    let delta1: float = this.delta;
    let delta2: float = this.delta;
    let out_of_bounds_sentry: boolean = false;
    let count: number = maxIter;
    let fResult: { f0: float, f1: float, f2: float };
    let temp: float;

    do {
      this.lastF0 = this.f0;
      delta2 = delta1;
      delta1 = this.delta;
      fResult = <{f0: float, f1: float, f2: float}>this.f(this.result);
      this.f0 = fResult.f0;
      this.f1 = fResult.f1;
      this.f2 = fResult.f2;
      count--;

      if (Comparison.isZero(this.f0)) {
        break;
      }

      if (Comparison.isZero(this.f1)) {
        // Oops zero derivative!!!
        this.handleZeroDerivative();
      } else {
        if (!Comparison.isZero(this.f2)) {
          this.delta = step(this.result, this.f0, this.f1, this.f2);
          if (Comparison.isNegative(Basic.divideFF(
            Basic.multiplyFF(this.delta, this.f1, this.p),
            this.f0,
            this.p
          ))) {
            // Oh dear, we have a problem as Newton and Halley steps
            // disagree about which way we should move.  Probably
            // there is cancelation error in the calculation of the
            // Halley step, or else the derivatives are so small
            // that their values are basically trash.  We will move
            // in the direction indicated by a Newton step, but
            // by no more than twice the current guess value, otherwise
            // we can jump way out of bounds if we're not careful.
            // See https://svn.boost.org/trac/boost/ticket/8314.
            this.delta = Basic.divideFF(this.f0, this.f1, this.p);
            if (Comparison.gt(
              Sign.absF(this.delta),
              temp = Basic.multiplyFF(C.F_2, Sign.absF(this.guess), this.p))) {
              this.delta = temp;
              if (Comparison.isNegative(this.delta)) {
                this.delta = Sign.negateF(this.delta);
              }
            }
          }
        } else {
          this.delta = Basic.divideFF(this.f0, this.f1, this.p);
        }
      }

      let convergence = Sign.absF(Basic.divideFF(this.delta, delta2, this.p));

      if (Comparison.gt(convergence, RATIO.value(4, 5, this.p))
        && Comparison.lt(convergence, C.F_2)) {
        // last two steps haven't converged, try bisection:
        this.delta = Comparison.isPositive(this.delta) ?
          Basic.multiplyFF(
            Basic.subtractFF(this.result, this.min, this.p),
            C.F_ONE_HALF,
            this.p
          )
          :
          Basic.multiplyFF(
            Basic.subtractFF(this.result, this.max, this.p),
            C.F_ONE_HALF,
            this.p
          );

        if (Comparison.gt(Sign.absF(this.delta), this.result)) {
          // protect against huge jumps!
          this.delta = Sign.f(this.delta) === 1 ? this.result : Sign.negateF(this.result);
        }
        // reset delta2 so that this branch will *not* be taken on the
        // next iteration:
        delta2 = Basic.multiplyFF(this.delta, C.F_3, this.p);
      }
      this.guess = this.result;
      this.result = Basic.subtractFF(this.result, this.delta, this.p);

      // check for out of bounds step:
      if (Comparison.lt(this.result, this.min)) {
        let diff = Basic.divideFF(this.result, this.min, this.p);
        if (Comparison.ltOne(Sign.absF(diff))) {
          diff = Basic.reciprocalF(diff, this.p);
        }

        if (!out_of_bounds_sentry
          && Comparison.isPositive(diff)
          && Comparison.lt(diff, C.F_3)) {
          // Only a small out of bounds step, lets assume that the result
          // is probably approximately at min:
          this.delta = Basic.multiplyFF(
            RATIO.value(99, 100, this.p),
            Basic.subtractFF(this.guess, this.min, this.p),
            this.p
          );
          this.result = Basic.subtractFF(this.guess, this.delta, this.p);
          out_of_bounds_sentry = true; // only take this branch once!
        } else {
          this.delta = Basic.multiplyFF(
            C.F_ONE_HALF,
            Basic.subtractFF(this.guess, this.min, this.p),
            this.p
          );
          this.result = Basic.subtractFF(this.guess, this.delta, this.p);
          if (Comparison.equals(this.result, this.min)
            || Comparison.equals(this.result, this.max)) {
            break;
          }
        }
      } else if (Comparison.gt(this.result, this.max)) {
        let diff = Basic.divideFF(this.result, this.max, this.p);

        if (Comparison.ltOne(Sign.absF(diff))) {
          diff = Basic.reciprocalF(diff, this.p);
        }

        if (!out_of_bounds_sentry
          && Comparison.isPositive(diff)
          && Comparison.lt(diff, C.F_3)) {
          // Only a small out of bounds step, lets assume that the result
          // is probably approximately at min:
          this.delta = Basic.multiplyFF(
            RATIO.value(99, 100, this.p),
            Basic.subtractFF(this.guess, this.max, this.p),
            this.p
          );
          this.result = Basic.subtractFF(this.guess, this.delta, this.p);
          out_of_bounds_sentry = true; // only take this branch once!
        } else {
          this.delta = Basic.multiplyFF(
            C.F_ONE_HALF,
            Basic.subtractFF(this.guess, this.max, this.p),
            this.p
          );
          this.result = Basic.subtractFF(this.guess, this.delta, this.p);
          if (Comparison.equals(this.result, this.min)
            || Comparison.equals(this.result, this.max)) {
            break;
          }
        }
      }
      // update brackets:
      if (Comparison.isPositive(this.delta)) {
        this.max = this.guess;
      } else {
        this.min = this.guess;
      }

    } while (count
    && Comparison.lt(
      Sign.absF(Basic.multiplyFF(this.result, this.p.epsilon, this.p)),
      Sign.absF(this.delta)
    ));

    maxIter -= count;


    return {result: this.result, iterations: maxIter};
  }

  private halleyStep(
    x: float,
    f0: float,
    f1: float,
    f2: float
  ): float {
    const denom = Basic.multiplyFF(C.F_2, f0, this.p);
    const num = Basic.subtractFF(
      Basic.multiplyFF(C.F_2, f1, this.p),
      Basic.multiplyFF(f0, Basic.divideFF(f2, f1, this.p), this.p),
      this.p
    );

    return Basic.divideFF(denom, num, this.p);
  }

  private schroderStep(
    x: float,
    f0: float,
    f1: float,
    f2: float
  ): float {
    const ratio = Basic.divideFF(f0, f1, this.p);
    let delta: float;

    if (Comparison.lt(
      Basic.divideFF(ratio, x, this.p),
      RATIO.value(1, 10, this.p)
    )) {
      delta = Basic.addFF(
        ratio,
        Basic.multiplyFF(
          Basic.divideFF(f2, Basic.multiplyFF(C.F_2, f1, this.p), this.p),
          Basic.squareF(ratio, this.p),
          this.p
        ),
        this.p
      );

      if (Sign.f(delta) * Sign.f(ratio) < 0) {
        delta = ratio;
      }
    } else {
      // fall back to Newtonian iteration
      delta = ratio;
    }

    return delta;
  }

  public static bisect(
    f: (x: float) => float,
    min: float,
    max: float,
    tol: Tol,
    maxIter: number,
    p: P
  ): { a: float, b: float, iterations: number } {
    let fMin = f(min);
    let fMax = f(max);

    if (Comparison.isZero(fMin)) {
      return {a: min, b: min, iterations: 2};
    }

    if (Comparison.isZero(fMax)) {
      return {a: max, b: max, iterations: 2};
    }

    //
    // Error checking:
    //
    if (Comparison.gte(min, max)) {
      throw new DomainError(
        Roots.className,
        "bisect",
        {
          f: {value: f, expectedType: "function"},
          min: {value: min, expectedType: "float"},
          max: {value: max, expectedType: "float"},
          tol: {value: tol, expectedType: "function"},
          maxIter: {value: maxIter, expectedType: "number"},
          p: {value: p, expectedType: "P"}
        },
        `In the bisection function, output is undefined for arguments min >= max`
      );
    }
    if (!Comparison.isNegative(Basic.multiplyFF(fMin, fMax, p))) {
      throw new DomainError(
        Roots.className,
        "bisect",
        {
          f: {value: f, expectedType: "function"},
          min: {value: min, expectedType: "float"},
          max: {value: max, expectedType: "float"},
          tol: {value: tol, expectedType: "function"},
          maxIter: {value: maxIter, expectedType: "number"},
          p: {value: p, expectedType: "P"}
        },
        `No change of sign between f(min) and f(max). Either there is no root to find,${""
        } or there are multiple roots in the interval.`
      );
    }

    //
    // two function invocations so far:
    //
    let count = maxIter;
    if (count < 2) {
      count = 0;
    } else {
      count -= 2;
    }


    while (count && (!tol(min, max))) {
      let mid = Basic.multiplyFF(Basic.addFF(min, max, p), C.F_ONE_HALF, p);
      let fMid = f(mid);
      --count;

      if (Comparison.equals(mid, max) || Comparison.equals(mid, min)) {
        break;
      }

      if (Comparison.isZero(fMid)) {
        min = mid;
        max = mid;
        break;
      } else if (Sign.f(fMid) * Sign.f(fMin) < 0) {
        max = mid;
        fMax = fMid;
      } else {
        min = mid;
        fMin = fMid;
      }
    }

    maxIter -= count;

    return {a: min, b: max, iterations: maxIter};
  }

  public static newtonRaphsonIterate(
    f: (x: float) => { f0: float, f1: float },
    guess: float,
    min: float,
    max: float,
    maxIter: number,
    p: P
  ): { result: float, iterations: number } {
    const r = new Roots(f, guess, min, max, p);
    return r.newtonRaphsonIterate(maxIter);
  }

  public static halleyIterate(
    f: (x: float) => { f0: float, f1: float, f2: float },
    guess: float,
    min: float,
    max: float,
    maxIter: number,
    p: P
  ): { result: float, iterations: number } {
    const r = new Roots(f, guess, min, max, p);
    return r.secondOrderRootFinder(maxIter, r.halleyStep);
  }

  public static schroderIterate(
    f: (x: float) => { f0: float, f1: float, f2: float },
    guess: float,
    min: float,
    max: float,
    maxIter: number,
    p: P
  ): { result: float, iterations: number } {
    const r = new Roots(f, guess, min, max, p);
    return r.secondOrderRootFinder(maxIter, r.schroderStep);
  }


  // class dependencies
  public static dependencies(): Set<Class> {
    return new Set([
      C, Sign, Comparison, Basic, RATIO, DomainError,
    ]);
  }
}


// *** imports come at end to avoid circular dependency ***

// interface/type imports
import {Tol} from "./toms748";
import {float} from "../../interfacesAndTypes/float";
import {Class} from "../../interfacesAndTypes/Class";

import {P as PAlias} from "../../dataTypes/P";
export type P = PAlias;


// functional imports
import {C as CAlias} from "../../constants/C";
const C = CAlias;

import {Sign as SignAlias} from "../../basicFunctions/Sign";
const Sign = SignAlias;

import {Comparison as ComparisonAlias} from "../../basicFunctions/Comparison";
const Comparison = ComparisonAlias;

import {Basic as BasicAlias} from "../../basicFunctions/Basic";
const Basic = BasicAlias;

import {RATIO as RATIOAlias} from "../../constants/RATIO";
const RATIO = RATIOAlias;

import {DomainError as DomainErrorAlias} from "../../errors/DomainError";
const DomainError = DomainErrorAlias;


"use strict";

/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2018 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


export type Tol = (a: float, b: float) => boolean;


export class Toms748 {
  public static className: string;

  public static init0(): void {
    Toms748.className = "Toms748";
  }

  private readonly f: (x: float) => float;
  private a: float;
  private a0: float;
  private b: float;
  private b0: float;
  private d: float;
  private e: float;
  private u: float;
  private fa: float;
  private fb: float;
  private fd: float;
  private fe: float;
  private fu: float;
  private p: P;

  private constructor(
    f: (x: float) => float,
    a: float,
    b: float,
    fa: float,
    fb: float,
    p: P
  ) {
    this.f = f;
    this.a = a;
    this.b = b;
    this.fa = fa;
    this.fb = fb;
    this.a0 = C.F_NaN;
    this.b0 = C.F_NaN;
    this.d = C.F_NaN;
    this.e = C.F_NaN;
    this.u = C.F_NaN;
    this.fd = C.F_NaN;
    this.fe = C.F_NaN;
    this.fu = C.F_NaN;
    this.p = p;
  }


  public static epsTolerance(p: P, bits?: number): Tol {
    let eps = Basic.multiplyFF(C.F_4, p.epsilon, p);

    if (typeof bits === "number") {
      eps = Core.maxF(
        Pow.fi(C.F_2, Core.numberToIntUnchecked(1 - bits), p),
        eps
      );
    }

    return (x: float, y: float) => {
      const distBetweenAAndB = Sign.absF(Basic.subtractFF(x, y, p));
      const minAbsXY = Core.minF(Sign.absF(x), Sign.absF(y));
      return Comparison.lte(distBetweenAAndB, Basic.multiplyFF(eps, minAbsXY, p));
    }
  }

  public static equalFloor(): Tol {
    return (x: float, y: float) =>
      Comparison.equals(Conversion.floor(x), Conversion.floor(y));
  }

  public static equalCeil(): Tol {
    return (x: float, y: float) =>
      Comparison.equals(Conversion.ceil(x), Conversion.ceil(y));
  }

  public static equalNearestInteger(): Tol {
    return (x: float, y: float) =>
      Comparison.equals(Conversion.round(x), Conversion.round(y));
  }

  private bracket(c: float): void {
    //
    // Given a point c inside the existing enclosing interval
    // [a, b] sets a = c if f(c) === 0, otherwise finds the new
    // enclosing interval: either [a, c] or [c, b] and sets
    // d and fd to the point that has just been removed from
    // the interval.  In other words d is the third best guess
    // to the root.
    //
    const tol = Basic.multiplyFF(this.p.epsilon, C.F_2, this.p);
    //
    // If the interval [a,b] is very small, or if c is too close
    // to one end of the interval then we need to adjust the
    // location of c accordingly:
    //
    let temp: float;

    if (Comparison.lt(
      Basic.subtractFF(this.b, this.a, this.p),
      Basic.productF([C.F_2, tol, this.a], this.p)
    )) {
      c = Basic.addFF(
        this.a,
        Basic.multiplyFF(
          Basic.subtractFF(this.b, this.a, this.p),
          C.F_ONE_HALF,
          this.p
        ),
        this.p);
    } else if (Comparison.lte(
      c,
      temp = Basic.addFF(
        this.a,
        Basic.multiplyFF(Sign.absF(this.a), tol, this.p),
        this.p
      )
    )) {
      c = temp;
    } else if (Comparison.gte(
      c,
      temp = Basic.subtractFF(
        this.b,
        Basic.multiplyFF(Sign.absF(this.b), tol, this.p),
        this.p
      )
    )) {
      c = temp;
    }

    //
    // OK, lets invoke f(c):
    //
    const fc = this.f(c);
    //
    // if we have a zero then we have an exact solution to the root:
    //
    if (Comparison.isZero(fc)) {
      this.a = c;
      this.fa = C.F_0;
      this.d = C.F_0;
      this.fd = C.F_0;
      return;
    }
    //
    // Non-zero fc, update the interval:
    //
    if (Sign.f(this.fa) * Sign.f(fc) < 0) {
      this.d = this.b;
      this.fd = this.fb;
      this.b = c;
      this.fb = fc;
    } else {
      this.d = this.a;
      this.fd = this.fa;
      this.a = c;
      this.fa = fc;
    }

    return;
  }

  private secantInterpolate(): float {
    //
    // Performs standard secant interpolation of [a,b] given
    // function evaluations f(a) and f(b).  Performs a bisection
    // if secant interpolation would leave us very close to either
    // a or b.  Rationale: we only call this function when at least
    // one other form of interpolation has already failed, so we know
    // that the function is unlikely to be smooth with a root very
    // close to a or b.
    //

    const tol = Basic.multiplyFF(this.p.epsilon, C.F_5, this.p);
    const c = Basic.subtractFF(this.a, Basic.multiplyFF(
      Basic.divideFF(this.fa, Basic.subtractFF(this.fb, this.fa, this.p), this.p),
      Basic.subtractFF(this.b, this.a, this.p),
      this.p
    ), this.p);
    const condition1 = Comparison.lte(
      c,
      Basic.addFF(this.a, Basic.multiplyFF(Sign.absF(this.a), tol, this.p), this.p)
    );
    const condition2 = Comparison.gte(
      c,
      Basic.subtractFF(
        this.b,
        Basic.multiplyFF(Sign.absF(this.b), tol, this.p),
        this.p
      )
    );

    if (condition1 || condition2) {
      return Basic.multiplyFF(
        Basic.addFF(this.a, this.b, this.p),
        C.F_ONE_HALF,
        this.p
      );
    }

    return c;
  }

  private quadraticInterpolate(count: number): float {
    //
    // Performs quadratic interpolation to determine the next point,
    // takes count Newton steps to find the location of the
    // quadratic polynomial.
    //
    // Point d must lie outside of the interval [a,b], it is the third
    // best approximation to the root, after a and b.
    //
    // Note: this does not guarentee to find a root
    // inside [a, b], so we fall back to a secant step should
    // the result be out of range.
    //
    // Start by obtaining the coefficients of the quadratic polynomial:
    //
    const bb = Basic.divideFF(
      Basic.subtractFF(this.fb, this.fa, this.p),
      Basic.subtractFF(this.b, this.a, this.p),
      this.p
    );

    let aa = Basic.divideFF(
      Basic.subtractFF(this.fd, this.fb, this.p),
      Basic.subtractFF(this.d, this.b, this.p),
      this.p
    );

    aa = Basic.divideFF(
      Basic.subtractFF(aa, bb, this.p),
      Basic.subtractFF(this.d, this.a, this.p),
      this.p
    );

    if (Comparison.isZero(aa)) {
      // failure to determine coefficients, try a secant step:
      return this.secantInterpolate();
    }
    //
    // Determine the starting point of the Newton steps:
    //
    let c: float;
    if (Sign.f(aa) * Sign.f(this.fa) > 0) {
      c = this.a;
    } else {
      c = this.b;
    }
    //
    // Take the Newton steps:
    //
    for (let i = 1; i <= count; i++) {
      c = Basic.subtractFF(c, Basic.divideFF(
        Basic.addFF(this.fa, Basic.multiplyFF(
          Basic.addFF(
            bb,
            Basic.multiplyFF(aa, Basic.subtractFF(c, this.b, this.p), this.p),
            this.p
          ),
          Basic.subtractFF(c, this.a, this.p),
          this.p
          ),
          this.p
        ),
        Basic.addFF(bb, Basic.multiplyFF(aa, Basic.multiplyFF(
          C.F_2,
          Basic.subtractFF(c, Basic.subtractFF(this.a, this.b, this.p), this.p),
          this.p
        ), this.p), this.p),
        this.p
      ), this.p);
    }

    if (Comparison.lte(c, this.a) || Comparison.gte(c, this.b)) {
      // Oops, failure, try a secant step:
      c = this.secantInterpolate();
    }

    return c;
  }

  private cubicInterpolate(): float {
    //
    // Uses inverse cubic interpolation of f(x) at points
    // [a,b,d,e] to obtain an approximate root of f(x).
    // Points d and e lie outside the interval [a,b]
    // and are the third and forth best approximations
    // to the root that we have found so far.
    //
    // Note: this does not guarentee to find a root
    // inside [a, b], so we fall back to quadratic
    // interpolation in case of an erroneous result.
    //

    const q11 = Basic.multiplyFF(
      Basic.subtractFF(this.d, this.e, this.p),
      Basic.divideFF(this.fd, Basic.subtractFF(this.fe, this.fd, this.p), this.p),
      this.p
    ); //(d - e) * fd / (fe - fd);
    const q21 = Basic.multiplyFF(
      Basic.subtractFF(this.b, this.d, this.p),
      Basic.divideFF(this.fb, Basic.subtractFF(this.fd, this.fb, this.p), this.p),
      this.p
    ); //(b - d) * fb / (fd - fb);
    const q31 = Basic.multiplyFF(
      Basic.subtractFF(this.a, this.b, this.p),
      Basic.divideFF(this.fa, Basic.subtractFF(this.fb, this.fa, this.p), this.p),
      this.p
    );//(a - b) * fa / (fb - fa);
    const d21 = Basic.multiplyFF(
      Basic.subtractFF(this.b, this.d, this.p),
      Basic.divideFF(this.fd, Basic.subtractFF(this.fd, this.fb, this.p), this.p),
      this.p
    );//(b - d) * fd / (fd - fb);
    const d31 = Basic.multiplyFF(
      Basic.subtractFF(this.a, this.b, this.p),
      Basic.divideFF(this.fb, Basic.subtractFF(this.fb, this.fa, this.p), this.p),
      this.p
    );//(a - b) * fb / (fb - fa);
    const q22 = Basic.multiplyFF(
      Basic.subtractFF(d21, q11, this.p),
      Basic.divideFF(this.fb, Basic.subtractFF(this.fe, this.fb, this.p), this.p),
      this.p
    );//(d21 - q11) * fb / (fe - fb);
    const q32 = Basic.multiplyFF(
      Basic.subtractFF(d31, q21, this.p),
      Basic.divideFF(this.fa, Basic.subtractFF(this.fd, this.fa, this.p), this.p),
      this.p
    );//(d31 - q21) * fa / (fd - fa);
    const d32 = Basic.multiplyFF(
      Basic.subtractFF(d31, q21, this.p),
      Basic.divideFF(this.fd, Basic.subtractFF(this.fd, this.fa, this.p), this.p),
      this.p
    );//(d31 - q21) * fd / (fd - fa);
    const q33 = Basic.multiplyFF(
      Basic.subtractFF(d32, q22, this.p),
      Basic.divideFF(this.fa, Basic.subtractFF(this.fe, this.fa, this.p), this.p),
      this.p
    );//(d32 - q22) * fa / (fe - fa);

    const c = Basic.sumF([q31, q32, q33, this.a], this.p); //q31 + q32 + q33 + a;

    if (Comparison.lte(c, this.a) || Comparison.gte(c, this.b)) {
      // Out of bounds step, fall back to quadratic interpolation:
      return this.quadraticInterpolate(3);
    }

    return c;
  }

  get prof(): boolean {
    return Comparison.equals(this.fa, this.fb) ||
      Comparison.equals(this.fa, this.fd) ||
      Comparison.equals(this.fa, this.fe) ||
      Comparison.equals(this.fb, this.fd) ||
      Comparison.equals(this.fb, this.fe) ||
      Comparison.equals(this.fd, this.fe);
  }

  private solve(tol: Tol, maxIter: number): { a: float, b: float, iterations: number } {
    //
    // Main entry point and logic for Toms Algorithm 748
    // root finder.
    //
    let iterations;
    let count = maxIter;
    let c: float;

    // initialize a, b and fa, fb:
    if (Comparison.gte(this.a, this.b)) {
      throw new DomainError(
        Toms748.className,
        "instance method solve",
        {
          "this.a": {value: this.a, expectedType: "float"},
          "this.b": {value: this.b, expectedType: "float"},
        },
        `The lower bound and upper bound for root finding are out of order`
      );
    }

    if (tol(this.a, this.b) || Comparison.isZero(this.fa) || Comparison.isZero(this.fb)) {
      if (Comparison.isZero(this.fa)) {
        this.b = this.a;
      } else if (Comparison.isZero(this.fb)) {
        this.a = this.b;
      }
      return {a: this.a, b: this.b, iterations: 0}
    }

    if (Sign.f(this.fa) * Sign.f(this.fb) > 0) {
      throw new DomainError(
        Toms748.className,
        "instance method solve",
        {
          "this.a": {value: this.a, expectedType: "float"},
          "this.b": {value: this.b, expectedType: "float"},
        },
        `The lower bound and upper bound for root finding do not bracket the root`
      );
    }

    // dummy value for fd, e and fe:
    this.fe = this.e = this.fd = Core.numberToFloatUnchecked(1e5);

    if (!Comparison.isZero(this.fa)) {
      //
      // On the first step we take a secant step:
      //
      c = this.secantInterpolate();
      this.bracket(c); //Toms748.bracket(f, c, fps);
      count--;

      if (count && !Comparison.isZero(this.fa) && !tol(this.a, this.b)) {
        //
        // On the second step we take a quadratic interpolation:
        //
        c = this.quadraticInterpolate(2);
        this.e = this.d;
        this.fe = this.fd;
        this.bracket(c);
        count--;
      }
    }

    while (count && !Comparison.isZero(this.fa) && !tol(this.a, this.b)) {
      // save our brackets:
      this.a0 = this.a;
      this.b0 = this.b;
      //
      // Starting with the third step taken
      // we can use either quadratic or cubic interpolation.
      // Cubic interpolation requires that all four function values
      // fa, fb, fd, and fe are distinct, should that not be the case
      // then the instance variable prof will get set to true, and we'll end up
      // taking a quadratic step instead.
      //
      c = this.prof ? this.quadraticInterpolate(2) : this.cubicInterpolate();

      //
      // re-bracket, and check for termination:
      //
      this.e = this.d;
      this.fe = this.fd;
      this.bracket(c);
      if ((0 === --count) || Comparison.isZero(this.fa) || tol(this.a, this.b)) {
        break;
      }
      //
      // Now another interpolated step:
      //
      c = this.prof ? this.quadraticInterpolate(3) : this.cubicInterpolate();

      //
      // Bracket again, and check termination condition, update e:
      //
      this.bracket(c);
      if ((0 === --count) || Comparison.isZero(this.fa) || tol(this.a, this.b)) {
        break;
      }
      //
      // Now we take a double-length secant step:
      //
      if (Comparison.lt(Sign.absF(this.fa), Sign.absF(this.fb))) {
        this.u = this.a;
        this.fu = this.fa;
      } else {
        this.u = this.b;
        this.fu = this.fb;
      }
      c = Basic.subtractFF(this.u, Basic.multiplyFF(C.F_2, Basic.multiplyFF(
        Basic.divideFF(this.fu, Basic.subtractFF(this.fb, this.fa, this.p), this.p),
        Basic.subtractFF(this.b, this.a, this.p),
        this.p
      ), this.p), this.p);

      const condition1 = Comparison.gt(
        Sign.absF(Basic.subtractFF(c, this.u, this.p)),
        Basic.multiplyFF(
          Basic.subtractFF(this.b, this.a, this.p),
          C.F_ONE_HALF,
          this.p
        )
      );

      if (condition1) {
        c = Basic.addFF(
          this.a,
          Basic.multiplyFF(
            Basic.subtractFF(this.b, this.a, this.p),
            C.F_ONE_HALF,
            this.p
          ),
          this.p
        );
      }
      //
      // Bracket again, and check termination condition:
      //
      this.e = this.d;
      this.fe = this.fd;
      this.bracket(c);
      if ((0 === --count) || Comparison.isZero(this.fa) || tol(this.a, this.b)) {
        break;
      }

      //
      // And finally... check to see if an additional bisection step is
      // to be taken, we do this if we're not converging fast enough:
      //
      const condition2 = Comparison.lt(
        Basic.subtractFF(this.b, this.a, this.p),
        Basic.multiplyFF(
          C.F_ONE_HALF,
          Basic.subtractFF(this.b0, this.a0, this.p),
          this.p
        )
      );

      if (condition2) {
        continue;
      }
      //
      // bracket again on a bisection:
      //
      this.e = this.d;
      this.fe = this.fd;
      this.bracket(
        Basic.addFF(
          this.a,
          Basic.multiplyFF(
            Basic.subtractFF(this.b, this.a, this.p),
            C.F_ONE_HALF,
            this.p
          ),
          this.p
        )
      );
      count--;
    } // while loop

    iterations = maxIter - count;
    if (Comparison.isZero(this.fa)) {
      this.b = this.a;
    } else if (Comparison.isZero(this.fb)) {
      this.a = this.b;
    }

    return {a: this.a, b: this.b, iterations: iterations};
  }

  public static solve(
    f: (x: float) => float,
    ax: float,
    bx: float,
    fax: float,
    fbx: float,
    tol: Tol,
    maxIter: number,
    p: P
  ): { a: float, b: float, iterations: number } {
    const toms748 = new Toms748(f, ax, bx, fax, fbx, p);
    return toms748.solve(tol, maxIter);
  }

  public static bracketAndSolveRoot(
    f: (x: float) => float,
    guess: float,
    factor: float,
    rising: boolean,
    tol: Tol,
    maxIter: number,
    p: P
  ): { a: float, b: float, iterations: number } {
    //
    // Set up inital brackets:
    //
    let a: float = guess;
    let b: float = a;
    let fa: float = f(a);
    let fb: float = fa;
    //
    // Set up invocation count:
    //
    let count = maxIter - 1;

    let step = 32;

    if (fa.coef.neg === (guess.coef.neg ? !rising : rising)) {
      //
      // Zero is to the right of b, so walk upwards
      // until we find it:
      //
      while (Sign.f(fb) === Sign.f(fa)) {
        if (count === 0) {
          throw new CalculationError(
            Toms748.className,
            "bracketAndSolveRoot",
            "Unable to bracket root in given number of maximum iterations"
          );
        }
        //
        // Heuristic: normally it's best not to increase the step sizes as we'll just end
        // up with a really wide range to search for the root.  However, if the initial
        // guess was *really* bad then we need to speed up the search otherwise we'll take
        // forever if we're orders of magnitude out.  This happens most often if the guess
        // is a small value (say 1) and the result we're looking for is close to
        // std::numeric_limits<T>::min().
        //
        if ((maxIter - count) % step === 0) {
          factor = Basic.multiplyFF(C.F_2, factor, p);
          if (step > 1) {
            step = Math.trunc(step / 2);
          }
        }
        //
        // Now go ahead and move our guess by "factor":
        //
        a = b;
        fa = fb;
        b = Basic.multiplyFF(b, factor, p);
        fb = f(b);
        count--;
      }
    } else {
      if (Comparison.isZero(f(C.F_0))) {
        // Escape route just in case the answer is zero!
        maxIter -= count;
        maxIter += 1;
        return {a: C.F_0, b: C.F_0, iterations: maxIter};
      }

      //
      // Zero is to the left of a, so walk downwards
      // until we find it:
      //
      while (Sign.f(fb) === Sign.f(fa)) {
        if (Comparison.equals(a, C.F_0)) {

        }
        if (count === 0) {
          throw new CalculationError(
            Toms748.className,
            "bracketAndSolveRoot",
            "Unable to bracket root in given number of maximum iterations"
          );
        }
        //
        // Heuristic: normally it's best not to increase the step sizes as we'll just end
        // up with a really wide range to search for the root.  However, if the initial
        // guess was *really* bad then we need to speed up the search otherwise we'll take
        // forever if we're orders of magnitude out.  This happens most often if the guess
        // is a small value (say 1) and the result we're looking for is close to
        // std::numeric_limits<T>::min().
        //
        if ((maxIter - count) % step === 0) {
          factor = Basic.multiplyFF(C.F_2, factor, p);
          if (step > 1) {
            step = Math.trunc(step / 2)
          }
        }
        //
        // Now go ahead and move our guess by "factor":
        //
        b = a;
        fb = fa;
        a = Basic.divideFF(a, factor, p);
        fa = f(a);
        count--;
      }
    }
    maxIter -= count;
    maxIter += 1;
    const r = Toms748.solve(
      f,
      (Comparison.isNegative(a) ? b : a),
      (Comparison.isNegative(a) ? a : b),
      (Comparison.isNegative(a) ? fb : fa),
      (Comparison.isNegative(a) ? fa : fb),
      tol,
      count,
      p
    );
    r.iterations += maxIter;

    return r;
  }


  // class dependencies
  public static dependencies(): Set<Class> {
    return new Set([
      C, Sign, Core, Comparison, Basic, Conversion, Pow, CalculationError, DomainError,
    ]);
  }
}


// *** imports come at end to avoid circular dependency ***

// interface/type imports
import {float} from "../../interfacesAndTypes/float";
import {Class} from "../../interfacesAndTypes/Class";

import {P as PAlias} from "../../dataTypes/P";
export type P = PAlias;


// functional imports
import {C as CAlias} from "../../constants/C";
const C = CAlias;

import {Sign as SignAlias} from "../../basicFunctions/Sign";
const Sign = SignAlias;

import {Core as CoreAlias} from "../../core/Core";
const Core = CoreAlias;

import {Comparison as ComparisonAlias} from "../../basicFunctions/Comparison";
const Comparison = ComparisonAlias;

import {Basic as BasicAlias} from "../../basicFunctions/Basic";
const Basic = BasicAlias;

import {Conversion as ConversionAlias} from "../../core/Conversion";
const Conversion = ConversionAlias;

import {Pow as PowAlias} from "../../basicFunctions/Pow";
const Pow = PowAlias;

import {CalculationError as CalculationErrorAlias} from "../../errors/CalculationError";
const CalculationError = CalculationErrorAlias;

import {DomainError as DomainErrorAlias} from "../../errors/DomainError";
const DomainError = DomainErrorAlias;
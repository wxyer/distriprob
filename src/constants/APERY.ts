"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/**
 * This class calculates Apery's Constant to the desired precision. It uses a series
 * representation for the constant found by Sebastian Wedeniwski in 1998. It is as
 * follows:
 *
 *                      +inf
 *                     ------                            3
 *                     \           k   ((2k + 1)!(2k)!k!)
 * AperysConstant   =   \      (-1) ------------------------ Poly(k)
 *                      /                                 3
 *                     /              24(3k + 2)!(4k + 3)!
 *                     ------
 *                      k = 0
 *
 *  where:
 *                           5         4         3         2
 *          Poly(k) = 126392k + 412708k + 531578k + 336367k + 104000k + 12463
 */
export class APERY {
  private static _value: float;
  private static _baseDigits: number;

  public static value(p: P): float {
    if (typeof APERY._baseDigits === "undefined" || APERY._baseDigits < p.baseDigits) {
      APERY._value = APERY.calculate(p);
      APERY._baseDigits = p.baseDigits;
    }

    return APERY._value;
  }

  private static calculate(p: P): float {
    const iterations = Math.ceil(((p.baseDigits - 1) * 26)/16.7) + 1;
    const F_24 = WHOLE.float(24);
    let negative = false;
    let polynomial = WHOLE.float(12463);
    let kFact = C.F_1;
    let twoKFact = {value: C.F_1, index: 0, nextIndex: 2};
    let twoKPlus1Fact = {value: C.F_1, index: 1, nextIndex: 3};
    let threeKPlus2Fact = {value: C.F_2, index: 2, nextIndex: 5};
    let fourKPlus3Fact = {value: C.F_6, index: 3, nextIndex: 7};
    let termNum = polynomial;
    let termDenom = WHOLE.float(10368);
    let sumNum = termNum;
    let sumDenom = termDenom;

    for (let k = 1; k <= iterations; k++) {
      kFact = k <= FactorialTable.maxIndex ?
        FactorialTable.float(k)
        :
        Basic.multiplyFF(kFact, Core.numberToFloatUnchecked(k), p);

      twoKFact.nextIndex = 2 * k;
      FactorialTable.calcFact(twoKFact, p);

      twoKPlus1Fact.nextIndex = 2 * k + 1;
      FactorialTable.calcFact(twoKPlus1Fact, p);

      threeKPlus2Fact.nextIndex = 3 * k + 2;
      FactorialTable.calcFact(threeKPlus2Fact, p);

      fourKPlus3Fact.nextIndex = 4 * k + 3;
      FactorialTable.calcFact(fourKPlus3Fact, p);

      polynomial = APERY.getPolynomialValue(k, p);
      negative = !negative;

      termNum = Basic.multiplyFF(
        Pow.fi(
          Basic.productF([twoKPlus1Fact.value, twoKFact.value, kFact], p),
          C.I_3,
          p
        ),
        polynomial,
        p
      );
      termNum = negative ? Sign.negateF(termNum) : termNum;
      termDenom = Basic.productF([
        F_24,
        threeKPlus2Fact.value,
        Pow.fi(fourKPlus3Fact.value, C.I_3, p)
      ], p);

      sumNum = Basic.addFF(
        Basic.multiplyFF(sumNum, termDenom, p),
        Basic.multiplyFF(sumDenom, termNum, p),
        p
      );
      sumDenom = Basic.multiplyFF(sumDenom, termDenom, p);
    }

    return Basic.divideFF(sumNum, sumDenom, p);
  }

  private static getPolynomialValue(k: number, p: P): float {
    if (k <= 147) { // P is less than Number.MAX_SAFE_INTEGER
      const k2 = k * k;
      const k3 = k * k2;
      const k4 = k * k3;
      const k5 = k * k4;
      const resultNum = 126392 * k5 + 412708 * k4 + 531578 * k3 + 336367 * k2 +
        104000 * k + 12463;

      return Core.numberToFloatUnchecked(resultNum);
    } else {
      const kFloat = Core.numberToFloatUnchecked(k);
      const k2 = Basic.squareF(kFloat, p);
      const k3 = Basic.multiplyFF(kFloat, k2, p);
      const k4 = Basic.multiplyFF(kFloat, k3, p);
      const k5 = Basic.multiplyFF(kFloat, k4, p);

      return Basic.sumF([
        Basic.multiplyFF(WHOLE.float(126392), k5, p),
        Basic.multiplyFF(WHOLE.float(412708), k4, p),
        Basic.multiplyFF(WHOLE.float(531578), k3, p),
        Basic.multiplyFF(WHOLE.float(336367), k2, p),
        Basic.multiplyFF(WHOLE.float(104000), kFloat, p),
        WHOLE.float(12463)
      ], p);
    }
  }
}


// *** imports come at end to avoid circular dependency ***

import {float} from "../interfaces/float";

import {C as CAlias} from "./C";
const C = CAlias;

import {Sign as SignAlias} from "../basicFunctions/Sign";
const Sign = SignAlias;

import {Core as CoreAlias} from "../core/Core";
const Core = CoreAlias;

import {Basic as BasicAlias} from "../basicFunctions/Basic";
const Basic = BasicAlias;

import {Pow as PowAlias} from "../basicFunctions/Pow";
const Pow = PowAlias;

import {WHOLE as WHOLEAlias} from "./WHOLE";
const WHOLE = WHOLEAlias;

import {FactorialTable as FactorialTableAlias} from "./FactorialTable";
const FactorialTable = FactorialTableAlias;

import {P as PAlias} from "../dataTypes/P";
export type P = PAlias;


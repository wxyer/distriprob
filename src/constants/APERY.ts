"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

import {float} from "../interfaces/float";

import {C as CAlias} from "./C";
const C = CAlias;

import {Sign as SignAlias} from "../basicFunctions/Sign";
const Sign = SignAlias;

import {Core as CoreAlias} from "../core/Core";
const Core = CoreAlias;

import {Basic as BasicAlias} from "../basicFunctions/Basic";
const Basic = BasicAlias;

import {Pow as PowAlias} from "../basicFunctions/Pow";
const Pow = PowAlias;

import {WHOLE as WHOLEAlias} from "./WHOLE";
const WHOLE = WHOLEAlias;

import {FactorialTable as FactorialTableAlias} from "./FactorialTable";
const FactorialTable = FactorialTableAlias;

import {P as PAlias} from "../core/P";
const P = PAlias;
export type P = PAlias;


export class APERY {
  private static _value: float;
  private static _numDigits: number;

  public static value(prec: P): float {
    if (typeof APERY._numDigits === "undefined" || APERY._numDigits < prec.numDigits) {
      APERY._value = APERY.calculate(prec);
      APERY._numDigits = prec.numDigits;
    }

    return APERY._value;
  }

  private static calculate(prec: P): float {
    const iterations = Math.ceil(((prec.numDigits - 1) * 26)/16.7) + 1;
    const F_24 = WHOLE.float(24);
    let negative = false;
    let p = WHOLE.float(12463);
    let kFact = C.F_1;
    let twoKFact = {value: C.F_1, index: 0, nextIndex: 2};
    let twoKPlus1Fact = {value: C.F_1, index: 1, nextIndex: 3};
    let threeKPlus2Fact = {value: C.F_2, index: 2, nextIndex: 5};
    let fourKPlus3Fact = {value: C.F_6, index: 3, nextIndex: 7};
    let termNum = p;
    let termDenom = WHOLE.float(10368);
    let sumNum = termNum;
    let sumDenom = termDenom;

    for (let k = 1; k <= iterations; k++) {
      kFact = k <= FactorialTable.maxIndex ?
        FactorialTable.float(k)
        :
        Basic.multiplyFF(kFact, Core.numberToFloatUnchecked(k), prec);

      twoKFact.nextIndex = 2 * k;
      FactorialTable.calcFact(twoKFact, prec);

      twoKPlus1Fact.nextIndex = 2 * k + 1;
      FactorialTable.calcFact(twoKPlus1Fact, prec);

      threeKPlus2Fact.nextIndex = 3 * k + 2;
      FactorialTable.calcFact(threeKPlus2Fact, prec);

      fourKPlus3Fact.nextIndex = 4 * k + 3;
      FactorialTable.calcFact(fourKPlus3Fact, prec);

      p = APERY.getP(k, prec);
      negative = !negative;

      termNum = Basic.multiplyFF(
        Pow.fi(
          Basic.productF([twoKPlus1Fact.value, twoKFact.value, kFact], prec),
          C.I_3,
          prec
        ),
        p,
        prec
      );
      termNum = negative ? Sign.negateF(termNum) : termNum;
      termDenom = Basic.productF([
        F_24,
        threeKPlus2Fact.value,
        Pow.fi(fourKPlus3Fact.value, C.I_3, prec)
      ], prec);

      sumNum = Basic.addFF(
        Basic.multiplyFF(sumNum, termDenom, prec),
        Basic.multiplyFF(sumDenom, termNum, prec),
        prec
      );
      sumDenom = Basic.multiplyFF(sumDenom, termDenom, prec);
    }

    return Basic.divideFF(sumNum, sumDenom, prec);
  }

  private static getP(k: number, prec: P): float {
    if (k <= 147) { // P is less than Number.MAX_SAFE_INTEGER
      const k2 = k * k;
      const k3 = k * k2;
      const k4 = k * k3;
      const k5 = k * k4;
      const resultNum = 126392 * k5 + 412708 * k4 + 531578 * k3 + 336367 * k2 +
        104000 * k + 12463;

      return Core.numberToFloatUnchecked(resultNum);
    } else {
      const kFloat = Core.numberToFloatUnchecked(k);
      const k2 = Basic.squareF(kFloat, prec);
      const k3 = Basic.multiplyFF(kFloat, k2, prec);
      const k4 = Basic.multiplyFF(kFloat, k3, prec);
      const k5 = Basic.multiplyFF(kFloat, k4, prec);

      return Basic.sumF([
        Basic.multiplyFF(WHOLE.float(126392), k5, prec),
        Basic.multiplyFF(WHOLE.float(412708), k4, prec),
        Basic.multiplyFF(WHOLE.float(531578), k3, prec),
        Basic.multiplyFF(WHOLE.float(336367), k2, prec),
        Basic.multiplyFF(WHOLE.float(104000), kFloat, prec),
        WHOLE.float(12463)
      ], prec);
    }
  }
}


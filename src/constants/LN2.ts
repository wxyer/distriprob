"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


/**
 * This static class evaluates the natural log of 2 for a given precision. It does so by
 * approximating the right hand side of valid equations of the form:
 *
 *    ln2 = coef0 * L(k0) + coef1 * L(k1) + coef2 * L(k2) + . . .
 *
 *    where L(k) = arctanh(1/k)
 *
 * note that one series approximation for L(k) is
 *
 *        _inf_
 *   1    \                   1
 *  --- *  \        --------------------
 *   k     /          (2*n + 1)*(k^2)^n
 *        /____
 *        n = 0
 *
 *  The current equation of this form that is approximated is:
 *
 *      ln2 = 144 * L(251) + 54 * L(449) - 38 * L(4801) + 62 * L(8749)
 *
 *  Some other possibilities that don't converge as quickly are:
 *
 *      ln2 = 18 * L(26) - 2 * L(4801) + 8 * L(8749)
 *      ln2 = 72 * L(127) + 54 * L(449) + 34 * L(4801) - 10 * L(8749)
 */
export class LN2 {
  public static className: string;

  public static init0(): void {
    LN2.className = "LN2";
  }

  private static _equation: Array<{coef: float, k: float, k2: float}>;
  private static _value: float;
  private static _baseDigits: number;
  private static _reciprocal: float;
  private static _recipBaseDigits: number;

  public static init1(): void {
    const squareP = PREC.getPFromBaseDigits(3);
    const coefs: float[] = [
      WHOLE.float(144),
      WHOLE.float(54),
      WHOLE.float(-38),
      WHOLE.float(62)
    ];
    const ks: float[] = [
      WHOLE.float(251),
      WHOLE.float(449),
      WHOLE.float(4801),
      WHOLE.float(8749)
    ];

    LN2._equation = [];

    for (let i = 0; i < coefs.length; i++) {
      LN2._equation.push({
        coef: coefs[i],
        k: ks[i],
        k2: Basic.squareF(ks[i], squareP)
      });
    }
  }

  public static value(p: P): float {
    if (!LN2._baseDigits || LN2._baseDigits < p.baseDigits) {
      LN2._value = LN2.calc(p);
      LN2._baseDigits = p.baseDigits;
    }

    return LN2._value;
  }

  public static reciprocal(p: P): float {
    if (!LN2._recipBaseDigits || LN2._recipBaseDigits < p.baseDigits) {
      LN2._reciprocal = Basic.reciprocalF(LN2.value(p), p);
      LN2._recipBaseDigits = p.baseDigits;
    }

    return LN2._reciprocal;
  }

  private static calc(p: P): float {
    const iterations = Math.ceil(p.binDigits/15.943087107901544) + 1;
    const limit = (2 * iterations) + 1;
    const num = Array(LN2._equation.length).fill(C.F_1);
    const denom = Array(LN2._equation.length).fill(C.F_1);
    let nFloat: float;
    let nextTermDenom: float;
    let kPow = Array(LN2._equation.length).fill(C.F_1);

    for (let n = 3; n <= limit; n = n + 2) {
      nFloat = Core.numberToFloatUnchecked(n);

      for (let i = 0; i < LN2._equation.length; i++) {
        kPow[i] = Basic.multiplyFF(kPow[i], LN2._equation[i].k2, p);
        nextTermDenom = Basic.multiplyFF(nFloat, kPow[i], p);
        num[i] = Basic.addFF(
          Basic.multiplyFF(num[i], nextTermDenom, p),
          denom[i],
          p
        );
        denom[i] = Basic.multiplyFF(denom[i], nextTermDenom, p);
      }
    }

    let finalNumerator: float = Basic.multiplyFF(LN2._equation[0].coef, num[0], p);
    let finalDenominator: float = Basic.multiplyFF(LN2._equation[0].k, denom[0], p);

    for(let i = 1; i < LN2._equation.length; i++) {
      num[i] = Basic.multiplyFF(LN2._equation[i].coef, num[i], p);
      denom[i] = Basic.multiplyFF(LN2._equation[i].k, denom[i], p);

      finalNumerator = Basic.addFF(
        Basic.multiplyFF(finalNumerator, denom[i], p),
        Basic.multiplyFF(finalDenominator, num[i], p),
        p
      );
      finalDenominator = Basic.multiplyFF(finalDenominator, denom[i], p);
    }

    return Basic.divideFF(finalNumerator, finalDenominator, p);
  }


  // class dependencies
  public static dependencies(): Set<Class> {
    return new Set([
      C, Core, Basic, WHOLE, PREC,
    ]);
  }
}


// *** imports come at end to avoid circular dependency ***

// interface/type imports
import {float} from "../interfaces/float";
import {Class} from "../interfaces/Class";

import {P as PAlias} from "../dataTypes/P";
export type P = PAlias;


// functional imports
import {C as CAlias} from "./C";
const C = CAlias;

import {Core as CoreAlias} from "../core/Core";
const Core = CoreAlias;

import {Basic as BasicAlias} from "../basicFunctions/Basic";
const Basic = BasicAlias;

import {WHOLE as WHOLEAlias} from "./WHOLE";
const WHOLE = WHOLEAlias;

import {PREC as PRECAlias} from "./PREC";
const PREC = PRECAlias;
